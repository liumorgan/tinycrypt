; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	c:\hub\tinycrypt\block\noekeon\n.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_noekeon
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\noekeon\n.c
;	COMDAT _noekeon
_TEXT	SEGMENT
_rc_tab$ = -44						; size = 17
tv462 = -24						; size = 4
tv452 = -20						; size = 4
tv439 = -16						; size = 4
tv422 = -12						; size = 4
_i$ = -8						; size = 4
_s1$ = -4						; size = 4
_s3$ = 8						; size = 4
_key$ = 8						; size = 4
_t$ = 12						; size = 4
_data$ = 12						; size = 4
_noekeon PROC						; COMDAT

; 33   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 34   :     int      i, j;
; 35   :     uint32_t s0, s1, s2, s3, t;
; 36   : 
; 37   :     uint32_t *s=(uint32_t*)data;
; 38   :     uint32_t *k=(uint32_t*)key;
; 39   : 
; 40   :     const uint8_t rc_tab[]=   
; 41   :       { 0x80,
; 42   :         0x1B, 0x36, 0x6C, 0xD8, 
; 43   :         0xAB, 0x4D, 0x9A, 0x2F, 
; 44   :         0x5E, 0xBC, 0x63, 0xC6, 
; 45   :         0x97, 0x35, 0x6A, 0xD4 };
; 46   :   
; 47   :     s0 = s[0]; s1 = s[1];
; 48   :     s2 = s[2]; s3 = s[3];
; 49   :     
; 50   :     for (i=0;;i++) {

	and	DWORD PTR _i$[ebp], 0
	push	ebx
	mov	ebx, DWORD PTR _data$[ebp]

; 51   :       s0 ^= rc_tab[i];

	mov	ecx, DWORD PTR [ebx]
	push	esi
	xor	ecx, 128				; 00000080H
	push	edi
	mov	edi, DWORD PTR [ebx+8]

; 52   :       // Theta
; 53   :       t = s0 ^ s2; 

	mov	eax, edi
	xor	eax, ecx

; 54   : 
; 55   :       t ^= ROTR32(t, 8) ^ ROTL32(t, 8);

	mov	edx, eax
	ror	edx, 8
	mov	esi, eax
	rol	esi, 8
	xor	edx, esi
	xor	eax, edx

; 56   : 
; 57   :       s1 ^= t; s3 ^= t;
; 58   : 
; 59   :       s0 ^= k[0]; s1 ^= k[1];

	mov	edx, DWORD PTR _key$[ebp]
	mov	esi, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ebx+4]
	xor	edx, esi
	xor	edx, eax
	mov	DWORD PTR _s1$[ebp], edx

; 60   :       s2 ^= k[2]; s3 ^= k[3];

	mov	edx, DWORD PTR _key$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR tv422[ebp], esi
	mov	esi, DWORD PTR [ebx+12]
	xor	esi, edx
	xor	esi, eax

; 61   : 
; 62   :       t = s1 ^ s3; 

	mov	eax, esi
	xor	eax, DWORD PTR _s1$[ebp]
	mov	DWORD PTR tv439[ebp], edx

; 63   :       t ^= ROTR32(t, 8) ^ ROTL32(t, 8);

	mov	edx, eax
	mov	DWORD PTR _t$[ebp], eax
	ror	edx, 8
	rol	eax, 8
	xor	edx, eax
	mov	eax, DWORD PTR _key$[ebp]
	mov	eax, DWORD PTR [eax]
	xor	DWORD PTR _t$[ebp], edx
	mov	DWORD PTR tv452[ebp], eax

; 64   : 
; 65   :       s0 ^= t; s2 ^= t;

	xor	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _rc_tab$[ebp], 1815485312	; 6c361b80H
	xor	ecx, eax
	mov	eax, DWORD PTR _key$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR tv462[ebp], eax
	xor	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _rc_tab$[ebp+4], -1706185768	; 9a4dabd8H
	mov	DWORD PTR _rc_tab$[ebp+8], 1673289263	; 63bc5e2fH
	mov	DWORD PTR _rc_tab$[ebp+12], 1781897158	; 6a3597c6H
	mov	BYTE PTR _rc_tab$[ebp+16], 212		; 000000d4H
	xor	edi, eax
$LL4@noekeon:

; 66   : 
; 67   :       if (i==Nr) break;
; 68   : 
; 69   :       // Pi1
; 70   :       s1 = ROTL32(s1, 1);

	mov	eax, DWORD PTR _s1$[ebp]

; 71   :       s2 = ROTL32(s2, 5);

	rol	edi, 5

; 72   :       s3 = ROTL32(s3, 2);

	rol	esi, 2
	rol	eax, 1

; 73   : 
; 74   :       // Gamma
; 75   :       s1 ^= ~(s3 | s2);

	mov	edx, esi
	or	edx, edi
	not	edx
	xor	eax, edx

; 76   :       s0 ^=   s2 & s1;  

	mov	edx, edi
	and	edx, eax
	xor	edx, ecx

; 77   : 
; 78   :       XCHG(s0, s3);
; 79   : 
; 80   :       s2 ^= s0 ^ s1 ^ s3;

	xor	edi, edx
	xor	edi, eax
	mov	DWORD PTR _s3$[ebp], edx
	mov	ecx, esi
	xor	edi, ecx

; 81   : 
; 82   :       s1 ^= ~(s3 | s2);

	or	edx, edi
	not	edx
	xor	eax, edx

; 83   :       s0 ^=   s2 & s1;  

	mov	edx, edi
	and	edx, eax
	xor	ecx, edx
	inc	DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR _rc_tab$[ebp+edx]
	xor	ecx, edx

; 84   : 
; 85   :       // Pi2
; 86   :       s1 = ROTR32(s1, 1);
; 87   :       s2 = ROTR32(s2, 5);

	ror	edi, 5
	mov	edx, edi
	xor	edx, ecx
	mov	esi, edx
	ror	esi, 8
	mov	DWORD PTR _t$[ebp], edx
	rol	edx, 8
	xor	esi, edx
	xor	DWORD PTR _t$[ebp], esi

; 88   :       s3 = ROTR32(s3, 2);

	mov	esi, DWORD PTR _s3$[ebp]
	ror	eax, 1
	xor	eax, DWORD PTR tv422[ebp]
	xor	eax, DWORD PTR _t$[ebp]
	ror	esi, 2
	xor	esi, DWORD PTR tv439[ebp]
	mov	DWORD PTR _s1$[ebp], eax
	xor	esi, DWORD PTR _t$[ebp]
	mov	eax, esi
	xor	eax, DWORD PTR _s1$[ebp]
	mov	edx, eax
	mov	DWORD PTR _t$[ebp], eax
	ror	edx, 8
	rol	eax, 8
	xor	edx, eax
	xor	DWORD PTR _t$[ebp], edx
	mov	eax, DWORD PTR tv452[ebp]
	xor	eax, DWORD PTR _t$[ebp]
	xor	ecx, eax
	mov	eax, DWORD PTR tv462[ebp]
	xor	eax, DWORD PTR _t$[ebp]
	xor	edi, eax
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jne	$LL4@noekeon

; 89   :     }
; 90   :     s[0] = s0; s[1]= s1;

	mov	eax, DWORD PTR _s1$[ebp]

; 91   :     s[2] = s2; s[3]= s3;

	mov	DWORD PTR [ebx+8], edi
	pop	edi
	mov	DWORD PTR [ebx+12], esi
	pop	esi
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	pop	ebx

; 92   : }

	leave
	ret	0
_noekeon ENDP
_TEXT	ENDS
END
