; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	c:\hub\tinycrypt\block\sparx\sparx.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_sparx_setkey
PUBLIC	_sparx_encrypt
PUBLIC	_AX
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\sparx\sparx.c
;	COMDAT _AX
_TEXT	SEGMENT
_w$ = 8							; size = 4
_AX	PROC						; COMDAT

; 32   : void AX(void *w) {

	push	esi

; 33   :     w32_t *x=(w32_t*)w;
; 34   :     
; 35   :     x->w[0]  = ROTL16(x->w[0], 9);
; 36   :     x->w[0] += x->w[1];

	mov	esi, DWORD PTR _w$[esp]
	push	7
	pop	ecx
	mov	ax, WORD PTR [esi]
	movzx	edx, WORD PTR [esi+2]
	ror	ax, cl
	add	ax, dx

; 37   :     
; 38   :     x->w[1]  = ROTL16(x->w[1], 2);

	rol	dx, 2

; 39   :     x->w[1] ^= x->w[0];  

	xor	dx, ax
	mov	WORD PTR [esi], ax
	mov	WORD PTR [esi+2], dx
	pop	esi

; 40   : }

	ret	0
_AX	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\sparx\sparx.c
;	COMDAT _sparx_encrypt
_TEXT	SEGMENT
tv523 = -4						; size = 4
_buf$ = 8						; size = 4
_key$ = 12						; size = 4
_sparx_encrypt PROC					; COMDAT

; 79   : {

	push	ecx
	push	esi
	mov	esi, DWORD PTR _buf$[esp+4]
	push	ebx
	push	ebp

; 80   :     uint32_t i, j, r, t;
; 81   :     w32_t    *x, *k;
; 82   :     
; 83   :     x=(w32_t*)buf;

	mov	DWORD PTR tv523[esp+16], 10		; 0000000aH
	push	edi
$LL4@sparx_encr:

; 84   :     k=(w32_t*)key;
; 85   :     
; 86   :     for (i=0; i<10; i++) {
; 87   :       for (j=0; j<4; j++) {

	push	4
	mov	edi, esi
	mov	esi, DWORD PTR _key$[esp+20]
	pop	ebp
$LL7@sparx_encr:

; 88   :         for (r=0; r<4; r++) {

	push	4
	pop	ebx
$LL10@sparx_encr:

; 89   :           x->x[j] ^= k->x[0]; k++;

	mov	eax, DWORD PTR [esi]
	add	esi, 4
	xor	DWORD PTR [edi], eax

; 90   :           
; 91   :           AX(&x->x[j]);     

	push	edi
	call	_AX
	pop	ecx
	sub	ebx, 1
	jne	SHORT $LL10@sparx_encr

; 84   :     k=(w32_t*)key;
; 85   :     
; 86   :     for (i=0; i<10; i++) {
; 87   :       for (j=0; j<4; j++) {

	add	edi, 4
	mov	DWORD PTR _key$[esp+16], esi
	sub	ebp, 1
	jne	SHORT $LL7@sparx_encr

; 92   :         }
; 93   :       }
; 94   :       t = x->w[0] ^ 

	mov	eax, DWORD PTR _buf$[esp+16]
	mov	esi, DWORD PTR _buf$[esp+16]
	movzx	ebx, WORD PTR [eax]
	movzx	edi, WORD PTR [eax+2]
	mov	ecx, ebx
	movzx	ebp, WORD PTR [esi+6]
	xor	ecx, edi
	movzx	esi, WORD PTR [esi+4]
	xor	ecx, esi
	xor	ecx, ebp

; 95   :           x->w[1] ^ 
; 96   :           x->w[2] ^ 
; 97   :           x->w[3];
; 98   :           
; 99   :       t = ROTL16(t, 8);

	mov	eax, ecx
	shr	ecx, 8
	shl	eax, 8
	movzx	edx, ax

; 100  : 
; 101  :       x->w[4] ^= x->w[2] ^ t;

	mov	eax, DWORD PTR _buf$[esp+16]
	or	edx, ecx
	xor	esi, edx

; 102  :       x->w[5] ^= x->w[1] ^ t;
; 103  :       x->w[6] ^= x->w[0] ^ t;

	xor	ebx, edx
	xor	WORD PTR [eax+8], si
	mov	esi, eax
	mov	ax, WORD PTR [esi+10]

; 104  :       x->w[7] ^= x->w[3] ^ t;
; 105  : 
; 106  :       XCHG(x->x[0], x->x[2]);

	mov	ecx, DWORD PTR [esi]
	xor	ax, di
	xor	WORD PTR [esi+12], bx
	xor	ax, dx
	mov	WORD PTR [esi+10], ax
	mov	ax, WORD PTR [esi+14]
	xor	ax, bp
	xor	ax, dx
	sub	DWORD PTR tv523[esp+20], 1
	mov	WORD PTR [esi+14], ax
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi], eax

; 107  :       XCHG(x->x[1], x->x[3]);

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+12], ecx
	jne	$LL4@sparx_encr

; 108  :     }
; 109  : 
; 110  :     for (i=0; i<4; i++) {    

	mov	ecx, DWORD PTR _key$[esp+16]
	push	4
	pop	edx
	pop	edi
	pop	ebp
	pop	ebx
$LL13@sparx_encr:

; 111  :       x->x[0] ^= k->x[0]; 

	mov	eax, DWORD PTR [ecx]

; 112  :       x++; k++;

	lea	ecx, DWORD PTR [ecx+4]
	xor	DWORD PTR [esi], eax
	lea	esi, DWORD PTR [esi+4]
	sub	edx, 1
	jne	SHORT $LL13@sparx_encr
	pop	esi

; 113  :     }
; 114  : }

	pop	ecx
	ret	0
_sparx_encrypt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\sparx\sparx.c
;	COMDAT _sparx_setkey
_TEXT	SEGMENT
_t$ = -12						; size = 12
_out$ = 8						; size = 4
_in$ = 12						; size = 4
_sparx_setkey PROC					; COMDAT

; 43   : {

	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, DWORD PTR _in$[esp+12]
	push	ebp
	push	esi
	push	edi

; 44   :     uint32_t c, i;
; 45   :     uint8_t  *subkeys=(uint8_t*)out;
; 46   :     w32_t    *key=(w32_t*)in;
; 47   :     uint32_t t[3];
; 48   :     
; 49   :     for (c=0; c<41; c++) {

	xor	ebp, ebp
$LL4@sparx_setk:

; 50   :       memcpy (subkeys, &key->w[0], 16);

	mov	eax, DWORD PTR _out$[esp+24]
	mov	esi, ebx
	mov	edi, eax

; 51   :       
; 52   :       subkeys += 16;

	add	eax, 16					; 00000010H

; 53   : 
; 54   :       AX(&key->x[0]);

	push	ebx
	mov	DWORD PTR _out$[esp+28], eax
	movsd
	movsd
	movsd
	movsd
	call	_AX

; 55   : 
; 56   :       key->w[2] += key->w[0];

	mov	ax, WORD PTR [ebx]

; 57   :       key->w[3] += key->w[1];
; 58   : 
; 59   :       AX(&key->x[4]);

	lea	esi, DWORD PTR [ebx+16]
	add	WORD PTR [ebx+4], ax
	mov	ax, WORD PTR [ebx+2]
	add	WORD PTR [ebx+6], ax
	push	esi
	call	_AX

; 60   : 
; 61   :       key->w[10] += key->w[8];

	mov	ax, WORD PTR [esi]

; 62   :       key->w[11] += key->w[9] + c + 1;
; 63   : 
; 64   :       for (i=0; i<3; i++) {
; 65   :         t[i] = key->x[5+i];

	lea	edi, DWORD PTR _t$[esp+36]
	add	WORD PTR [ebx+20], ax
	lea	esi, DWORD PTR [ebx+20]
	mov	ax, WORD PTR [ebx+18]
	inc	ax
	add	ax, bp
	add	WORD PTR [ebx+22], ax
	movsd
	pop	ecx
	pop	ecx

; 66   :       }
; 67   : 
; 68   :       for (i=15; i>5; i--) {

	push	15					; 0000000fH
	movsd
	pop	ecx
	movsd
$LL10@sparx_setk:

; 69   :         key->w[i] = key->w[i-6];

	mov	ax, WORD PTR [ebx+ecx*2-12]
	mov	WORD PTR [ebx+ecx*2], ax
	dec	ecx
	cmp	ecx, 5
	ja	SHORT $LL10@sparx_setk

; 70   :       }
; 71   : 
; 72   :       for (i=0; i<3; i++) {
; 73   :         key->x[i] = t[i];  

	mov	edi, ebx
	lea	esi, DWORD PTR _t$[esp+28]
	inc	ebp
	movsd
	movsd
	movsd
	cmp	ebp, 41					; 00000029H
	jb	SHORT $LL4@sparx_setk
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 74   :       }
; 75   :     }
; 76   : }

	add	esp, 12					; 0000000cH
	ret	0
_sparx_setkey ENDP
_TEXT	ENDS
END
