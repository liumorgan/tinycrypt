; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	threefish
PUBLIC	add_key
;	COMDAT pdata
pdata	SEGMENT
$pdata$threefish DD imagerel $LN26
	DD	imagerel $LN26+278
	DD	imagerel $unwind$threefish
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_key DD imagerel $LN14
	DD	imagerel $LN14+179
	DD	imagerel $unwind$add_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_key DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$threefish DD 0a1b01H
	DD	013e41bH
	DD	012741bH
	DD	011641bH
	DD	010341bH
	DD	05014d21bH
xdata	ENDS
; Function compile flags: /Ogspy
; File c:\hub\threefish\tz.c
;	COMDAT add_key
_TEXT	SEGMENT
c$ = 8
data$ = 16
s$ = 24
add_key	PROC						; COMDAT

; 45   : {

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	movzx	r10d, r8b
	mov	rbx, rdx
	movzx	edi, r8b
	mov	r11, rcx

; 46   :     int i;
; 47   :     uint64_t x0, x1, x2;
; 48   :     uint64_t *x=(uint64_t*)data;
; 49   :     
; 50   :     for (i=0; i<4; i++) {

	mov	r8d, r10d
	xor	r9d, r9d
$LL4@add_key:

; 51   :       x0 = x[i];
; 52   :       x1 = c->k[(s + i) % 5];

	mov	eax, 1717986919				; 66666667H
	mov	ecx, r8d
	imul	r8d
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*4]
	sub	ecx, eax
	movsxd	rax, ecx

; 53   :       x2 = 0;

	xor	ecx, ecx
	mov	rsi, QWORD PTR [r11+rax*8]

; 54   :       
; 55   :       if (i==1) x2 = c->t[s % 3];

	cmp	r9, 1
	jne	SHORT $LN5@add_key
	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, r10d
	mul	r10d
	shr	edx, 1
	lea	eax, DWORD PTR [rdx+rdx*2]
	sub	ecx, eax
	movsxd	rax, ecx
	mov	rcx, QWORD PTR [r11+rax*8+40]
$LN5@add_key:

; 56   :       if (i==2) x2 = c->t[(s+1) % 3];

	cmp	r9, 2
	jne	SHORT $LN6@add_key
	lea	ecx, DWORD PTR [r10+1]
	mov	eax, -1431655765			; aaaaaaabH
	mul	ecx
	shr	edx, 1
	lea	eax, DWORD PTR [rdx+rdx*2]
	sub	ecx, eax
	movsxd	rax, ecx
	mov	rcx, QWORD PTR [r11+rax*8+40]
$LN6@add_key:

; 46   :     int i;
; 47   :     uint64_t x0, x1, x2;
; 48   :     uint64_t *x=(uint64_t*)data;
; 49   :     
; 50   :     for (i=0; i<4; i++) {

	cmp	r9, 3
	mov	rax, rdi
	cmovne	rax, rcx
	inc	r8d

; 57   :       if (i==3) x2 = s;
; 58   : 
; 59   :       x[i] = x0 + x1 + x2;

	add	rax, rsi
	add	QWORD PTR [rbx+r9*8], rax
	inc	r9
	cmp	r9, 4
	jl	SHORT $LL4@add_key

; 60   :     }
; 61   : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	ret	0
add_key	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\threefish\tz.c
;	COMDAT threefish
_TEXT	SEGMENT
rc$ = 32
c$ = 48
key$ = 128
tweak$ = 136
data$ = 144
threefish PROC						; COMDAT

; 64   : {

$LN26:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	mov	QWORD PTR [rax+32], r14
	push	rbp
	mov	rbp, rsp
	sub	rsp, 112				; 00000070H

; 65   :     int      i, j, r, s=0;
; 66   :     uint64_t t; 
; 67   :     key_t    c;
; 68   :     uint64_t *x=(uint64_t*)data;  
; 69   :     
; 70   :     uint8_t rc[16] = 
; 71   :     { 14, 52, 23,  5, 25, 46, 58, 32, 
; 72   :       16, 57, 40, 37, 33, 12, 22, 32};
; 73   : 
; 74   :     // copy key and tweak to local buffers  
; 75   :     memcpy((void*)c.k, key,   32);

	movups	xmm0, XMMWORD PTR [rcx]
	mov	rbx, r8
	xor	edi, edi
	movups	xmm1, XMMWORD PTR [rcx+16]
	mov	r8, rcx
	mov	DWORD PTR rc$[rbp-112], 85406734	; 0517340eH
	movaps	XMMWORD PTR c$[rbp-112], xmm0

; 76   :     memcpy((void*)c.t, tweak, 16);
; 77   :     
; 78   :     c.k[4] = 0x1BD11BDAA9FC1A22ULL;

	mov	rcx, 2004413935125273122		; 1bd11bdaa9fc1a22H
	movups	xmm0, XMMWORD PTR [rdx]
	mov	DWORD PTR rc$[rbp-108], 540683801	; 203a2e19H

; 79   :     
; 80   :     // initialize subkeys
; 81   :     for(i=0; i<4; i++){

	mov	eax, edi
	mov	DWORD PTR rc$[rbp-104], 623393040	; 25283910H
	movdqu	XMMWORD PTR c$[rbp-72], xmm0
	mov	DWORD PTR rc$[rbp-100], 538315809	; 20160c21H
	movaps	XMMWORD PTR c$[rbp-96], xmm1
$LL4@threefish:

; 82   :       c.k[4] ^= K(i);

	xor	rcx, QWORD PTR [r8+rax*8]
	inc	rax
	cmp	rax, 4
	jl	SHORT $LL4@threefish

; 83   :     }
; 84   :     c.t[2] = T(0) ^ T(1); 

	mov	rax, QWORD PTR [rdx+8]

; 85   :     
; 86   :     // apply 72 rounds
; 87   :     for (i=0; i<72; i++)

	mov	esi, edi
	xor	rax, QWORD PTR [rdx]
	mov	r14, rdi
	mov	QWORD PTR c$[rbp-56], rax
	mov	QWORD PTR c$[rbp-80], rcx
$LL7@threefish:

; 88   :     {
; 89   :       // add key every 4 rounds
; 90   :       if((i & 3) == 0) {

	test	sil, 3
	jne	SHORT $LN11@threefish

; 91   :         add_key(&c, data, s);

	mov	r8b, dil
	lea	rcx, QWORD PTR c$[rbp-112]
	mov	rdx, rbx
	call	add_key

; 92   :         s++;

	inc	edi
$LN11@threefish:

; 93   :       }
; 94   :         
; 95   :       // apply mixing function
; 96   :       for (j=0; j<4; j += 2) {

	mov	rax, r14
	lea	r8, QWORD PTR rc$[rbp-112]
	and	eax, 7
	mov	rdx, rbx
	add	r8, rax
	mov	r9d, 2
$LL10@threefish:

; 97   :         r = rc[(i & 7) + (j << 2)];

	mov	rax, QWORD PTR [rdx+8]
	add	QWORD PTR [rdx], rax
	movzx	ecx, BYTE PTR [r8]
	lea	r8, QWORD PTR [r8+8]

; 98   : 
; 99   :         x[j]   += x[j+1];
; 100  :         x[j+1]  = ROTL64(x[j+1], r);

	rol	rax, cl

; 101  :         x[j+1] ^= x[j];    

	xor	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdx+8], rax
	lea	rdx, QWORD PTR [rdx+16]
	sub	r9, 1
	jne	SHORT $LL10@threefish

; 102  :       }
; 103  :       
; 104  :       // permute
; 105  :       t    = x[1];

	mov	rcx, QWORD PTR [rbx+8]
	inc	esi

; 106  :       x[1] = x[3];

	mov	rax, QWORD PTR [rbx+24]
	inc	r14
	mov	QWORD PTR [rbx+8], rax

; 107  :       x[3] = t;

	mov	QWORD PTR [rbx+24], rcx
	cmp	esi, 72					; 00000048H
	jl	SHORT $LL7@threefish

; 108  :     }
; 109  :     // add key
; 110  :     add_key(&c, data, s);

	mov	r8b, dil
	lea	rcx, QWORD PTR c$[rbp-112]
	mov	rdx, rbx
	call	add_key

; 111  : }

	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rdi, QWORD PTR [r11+32]
	mov	r14, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rbp
	ret	0
threefish ENDP
_TEXT	ENDS
END
