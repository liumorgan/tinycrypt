; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	c:\hub\tinycrypt\block\lea\lea128.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_lea_setkey
PUBLIC	_lea_encrypt
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\lea\lea128.c
;	COMDAT _lea_encrypt
_TEXT	SEGMENT
_b3$1$ = -8						; size = 4
_t$1$ = -4						; size = 4
tv356 = 8						; size = 4
_roundKeys$ = 8						; size = 4
_block$ = 12						; size = 4
_lea_encrypt PROC					; COMDAT

; 64   : {

	push	ecx
	push	ecx
	push	ebx
	push	ebp
	push	esi

; 65   :     uint32_t* blk = (uint32_t*) block;
; 66   :     uint32_t* rk  = (uint32_t*) roundKeys;
; 67   :     uint32_t  t, b0, b1, b2, b3;
; 68   :     int       i;
; 69   :     
; 70   :     b0 = blk[0]; b1 = blk[1];

	mov	esi, DWORD PTR _block$[esp+16]
	push	edi

; 71   :     b2 = blk[2]; b3 = blk[3];

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi]
	mov	ebx, DWORD PTR [esi+4]
	mov	ebp, DWORD PTR [esi+8]
	mov	esi, DWORD PTR _roundKeys$[esp+20]
	mov	DWORD PTR _b3$1$[esp+24], eax
	add	esi, 4
	mov	DWORD PTR tv356[esp+20], 24		; 00000018H
$LL4@lea_encryp:

; 72   :     
; 73   :     for (i=0; i<LEA128_RNDS; i++, rk += 4) {
; 74   :       b3 = ROTR32((b2 ^ rk[3]) + (b3 ^ rk[1]), 3);
; 75   :       b2 = ROTR32((b1 ^ rk[2]) + (b2 ^ rk[1]), 5);
; 76   :       b1 = ROTL32((b0 ^ rk[0]) + (b1 ^ rk[1]), 9);

	mov	edx, DWORD PTR [esi]
	mov	eax, edx
	xor	eax, ebx

; 77   :       // rotate block 32-bits
; 78   :       XCHG(b0, b1);

	mov	DWORD PTR _t$1$[esp+24], edi
	xor	edi, DWORD PTR [esi-4]
	lea	esi, DWORD PTR [esi+16]
	xor	ebx, DWORD PTR [esi-12]
	add	edi, eax
	mov	eax, edx
	rol	edi, 9
	xor	edx, DWORD PTR _b3$1$[esp+24]
	xor	eax, ebp
	xor	ebp, DWORD PTR [esi-8]
	add	ebx, eax

; 79   :       XCHG(b1, b2);
; 80   :       XCHG(b2, b3);

	mov	eax, DWORD PTR _t$1$[esp+24]
	add	ebp, edx
	ror	ebx, 5
	ror	ebp, 3
	sub	DWORD PTR tv356[esp+20], 1
	mov	DWORD PTR _b3$1$[esp+24], eax
	jne	SHORT $LL4@lea_encryp

; 81   :     }
; 82   :     blk[0] = b0; blk[1] = b1;

	mov	esi, DWORD PTR _block$[esp+20]
	mov	DWORD PTR [esi], edi
	pop	edi
	mov	DWORD PTR [esi+4], ebx

; 83   :     blk[2] = b2; blk[3] = b3;

	mov	DWORD PTR [esi+8], ebp
	mov	DWORD PTR [esi+12], eax
	pop	esi
	pop	ebp
	pop	ebx

; 84   : }

	pop	ecx
	pop	ecx
	ret	0
_lea_encrypt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\lea\lea128.c
;	COMDAT _lea_setkey
_TEXT	SEGMENT
_k3$1$ = -20						; size = 4
_td$ = -16						; size = 16
_k2$1$ = 8						; size = 4
_key$ = 8						; size = 4
_roundKeys$ = 12					; size = 4
_lea_setkey PROC					; COMDAT

; 34   : {

	sub	esp, 20					; 00000014H

; 35   :     uint32_t *rk;
; 36   :     uint32_t k0, k1, k2, k3, i, t;
; 37   :     uint32_t td[4]= 
; 38   :         {0xc3efe9db, 0x44626b02, 0x79e27c8a, 0x78df30ec};
; 39   : 
; 40   :     rk = (uint32_t*)roundKeys;
; 41   :     
; 42   :     k0 = ((uint32_t*)key)[0]; k1 = ((uint32_t*)key)[1];

	mov	eax, DWORD PTR _key$[esp+16]
	push	ebx
	push	ebp
	push	esi

; 43   :     k2 = ((uint32_t*)key)[2]; k3 = ((uint32_t*)key)[3];

	mov	ecx, DWORD PTR [eax+8]

; 44   :     
; 45   :     td[1] = ROTL32(td[1], 1);
; 46   :     td[2] = ROTL32(td[2], 2);
; 47   :     td[3] = ROTL32(td[3], 3);
; 48   :     
; 49   :     for (i=0; i<LEA128_RNDS; i++, rk += 4) {

	xor	ebx, ebx
	mov	ebp, DWORD PTR [eax+4]
	mov	esi, DWORD PTR _roundKeys$[esp+28]
	push	edi
	mov	edi, DWORD PTR [eax]
	add	esi, 8
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _td$[esp+36], -1007687205	; c3efe9dbH
	mov	DWORD PTR _k2$1$[esp+32], ecx
	mov	DWORD PTR _k3$1$[esp+36], eax
	mov	DWORD PTR _td$[esp+40], -2000366076	; 88c4d604H
	mov	DWORD PTR _td$[esp+44], -410389975	; e789f229H
	mov	DWORD PTR _td$[esp+48], -956725405	; c6f98763H
$LL4@lea_setkey:

; 50   :       t         = td[i & 3];

	mov	ecx, ebx
	and	ecx, 3
	mov	edx, DWORD PTR _td$[esp+ecx*4+36]

; 51   :       td[i & 3] = ROTL32(t, 4);

	mov	eax, edx
	rol	eax, 4

; 52   :       
; 53   :       k0 = ROTL32(k0 + t, 1);

	add	edi, edx
	mov	DWORD PTR _td$[esp+ecx*4+36], eax

; 54   :       k1 = ROTL32(k1 + ROTL32(t, 1),  3);

	mov	eax, edx
	rol	eax, 1
	add	ebp, eax
	rol	edi, 1

; 55   :       k2 = ROTL32(k2 + ROTL32(t, 2),  6);

	mov	eax, edx
	rol	ebp, 3

; 56   :       k3 = ROTL32(k3 + ROTL32(t, 3), 11);

	rol	edx, 3
	add	edx, DWORD PTR _k3$1$[esp+36]
	rol	eax, 2
	add	eax, DWORD PTR _k2$1$[esp+32]
	rol	eax, 6
	rol	edx, 11					; 0000000bH
	inc	ebx

; 57   : 
; 58   :       rk[0] = k0; rk[1] = k1;

	mov	DWORD PTR [esi-8], edi
	mov	ecx, edx
	mov	DWORD PTR [esi-4], ebp

; 59   :       rk[2] = k2; rk[3] = k3;

	mov	DWORD PTR [esi], eax
	lea	esi, DWORD PTR [esi+16]
	mov	DWORD PTR [esi-12], ecx
	mov	DWORD PTR _k2$1$[esp+32], eax
	mov	DWORD PTR _k3$1$[esp+36], ecx
	cmp	ebx, 24					; 00000018H
	jb	SHORT $LL4@lea_setkey
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 60   :     }
; 61   : }

	add	esp, 20					; 00000014H
	ret	0
_lea_setkey ENDP
_TEXT	ENDS
END
