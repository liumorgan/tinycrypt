; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	c:\hub\tinycrypt\block\aes\aes_enc.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_aes_enc
PUBLIC	_aes_setkey
PUBLIC	_gf_mul2
PUBLIC	_gf_mulinv
PUBLIC	_SubByte
PUBLIC	_SubWord
PUBLIC	_SBSR
PUBLIC	_MixColumns
PUBLIC	_AddRoundKey
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\aes\aes_enc.c
;	COMDAT _AddRoundKey
_TEXT	SEGMENT
_c$ = 8							; size = 4
_s$ = 12						; size = 4
_rnd$ = 16						; size = 4
_AddRoundKey PROC					; COMDAT

; 144  :     uint32_t i;
; 145  : 
; 146  :     for (i=0; i<4; i++) {

	mov	ecx, DWORD PTR _rnd$[esp-4]
	xor	edx, edx
	shl	ecx, 4
	add	ecx, DWORD PTR _c$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
$LL4@AddRoundKe:

; 147  :       s->w[i] ^= c->w[4*rnd+i];

	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+4]
	xor	DWORD PTR [esi+edx*4], eax
	inc	edx
	cmp	edx, 4
	jb	SHORT $LL4@AddRoundKe
	pop	esi

; 148  :     }
; 149  : }

	ret	0
_AddRoundKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\aes\aes_enc.c
;	COMDAT _MixColumns
_TEXT	SEGMENT
_s$ = 8							; size = 4
_MixColumns PROC					; COMDAT

; 128  : {

	push	ebx
	push	ebp

; 129  :     uint32_t i, w;
; 130  : 
; 131  :     for (i=0; i<4; i++) {

	mov	ebp, DWORD PTR _s$[esp+4]
	xor	ebx, ebx
	push	esi
	push	edi
$LL4@MixColumns:

; 132  :       w = s[i];

	mov	esi, DWORD PTR [ebp+ebx*4]

; 133  :       s[i] = ROTR32(w,  8) ^ 

	mov	edi, esi
	ror	edi, 8
	mov	eax, edi
	xor	eax, esi
	push	eax
	call	_gf_mul2
	pop	ecx
	mov	ecx, esi
	rol	esi, 8
	rol	ecx, 16					; 00000010H
	xor	eax, ecx
	xor	eax, esi
	xor	eax, edi
	mov	DWORD PTR [ebp+ebx*4], eax
	inc	ebx
	cmp	ebx, 4
	jb	SHORT $LL4@MixColumns

; 134  :              ROTR32(w, 16) ^ 
; 135  :              ROTR32(w, 24) ^ 
; 136  :              gf_mul2(ROTR32(w, 8) ^ w);
; 137  :     }
; 138  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
_MixColumns ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\aes\aes_enc.c
;	COMDAT _SBSR
_TEXT	SEGMENT
_s$ = 8							; size = 4
_SBSR	PROC						; COMDAT

; 95   : {

	push	esi

; 96   :     uint8_t  *buf=(uint8_t*)s->b;
; 97   :     uint8_t  i, j;
; 98   :     uint32_t x;
; 99   :     
; 100  :     i = buf[1], 
; 101  :     buf[1]  = buf[5], 
; 102  :     buf[5]  = buf[9], 
; 103  :     buf[9]  = buf[13], 

	mov	esi, DWORD PTR _s$[esp]
	push	edi
	push	16					; 00000010H
	pop	edi
	mov	al, BYTE PTR [esi+5]
	mov	cl, BYTE PTR [esi+1]
	mov	BYTE PTR [esi+1], al
	mov	al, BYTE PTR [esi+9]
	mov	BYTE PTR [esi+5], al
	mov	al, BYTE PTR [esi+13]
	mov	BYTE PTR [esi+9], al

; 104  :     buf[13] = i;  
; 105  : 
; 106  :     i = buf[10], 
; 107  :     buf[10] = buf[2], 

	mov	al, BYTE PTR [esi+2]
	mov	BYTE PTR [esi+13], cl
	mov	cl, BYTE PTR [esi+10]
	mov	BYTE PTR [esi+10], al

; 108  :     buf[2]  = i;
; 109  :     
; 110  :     i = buf[3], 
; 111  :     buf[3]  = buf[15], 
; 112  :     buf[15] = buf[11], 
; 113  :     buf[11] = buf[7], 

	mov	al, BYTE PTR [esi+15]
	mov	BYTE PTR [esi+2], cl
	mov	cl, BYTE PTR [esi+3]
	mov	BYTE PTR [esi+3], al
	mov	al, BYTE PTR [esi+11]
	mov	BYTE PTR [esi+15], al
	mov	al, BYTE PTR [esi+7]
	mov	BYTE PTR [esi+11], al

; 114  :     buf[7]  = i;
; 115  :     
; 116  :     i = buf[14], 
; 117  :     buf[14] = buf[6], 

	mov	al, BYTE PTR [esi+6]
	mov	BYTE PTR [esi+7], cl
	mov	cl, BYTE PTR [esi+14]
	mov	BYTE PTR [esi+14], al
	mov	BYTE PTR [esi+6], cl
$LL4@SBSR:

; 118  :     buf[6]  = i;
; 119  :     
; 120  :     for (i=0; i<16; i++) {
; 121  :       buf[i] = SubByte(buf[i]);

	movzx	eax, BYTE PTR [esi]
	push	eax
	call	_SubByte
	mov	BYTE PTR [esi], al
	inc	esi
	pop	ecx
	sub	edi, 1
	jne	SHORT $LL4@SBSR

; 122  :     }
; 123  : }

	pop	edi
	pop	esi
	ret	0
_SBSR	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\aes\aes_enc.c
;	COMDAT _SubWord
_TEXT	SEGMENT
_x$ = 8							; size = 4
_SubWord PROC						; COMDAT

; 80   : {

	push	ebx
	push	esi
	push	edi

; 81   :     uint8_t  i;
; 82   :     uint32_t r=0;

	mov	edi, DWORD PTR _x$[esp+8]
	xor	esi, esi
	push	4
	pop	ebx
$LL4@SubWord:

; 83   : 
; 84   :     for (i=0; i<4; i++) {
; 85   :       r |= SubByte(x & 0xFF);

	push	edi
	call	_SubByte
	movzx	eax, al
	or	esi, eax

; 86   :       r  = ROTR32(r, 8);
; 87   :       x >>= 8;

	shr	edi, 8
	ror	esi, 8
	pop	ecx
	sub	ebx, 1
	jne	SHORT $LL4@SubWord

; 88   :     }
; 89   :     return r;

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 90   : }

	ret	0
_SubWord ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\aes\aes_enc.c
;	COMDAT _SubByte
_TEXT	SEGMENT
_x$ = 8							; size = 1
_SubByte PROC						; COMDAT

; 66   :     uint8_t i, y=0, sb;
; 67   : 
; 68   :     sb = y = gf_mulinv (x);

	push	DWORD PTR _x$[esp-4]
	call	_gf_mulinv
	pop	ecx
	push	4
	mov	cl, al
	pop	edx
$LL4@SubByte:

; 69   : 
; 70   :     for (i=0; i<4; i++) {
; 71   :       y   = ROTL8(y, 1);

	rol	cl, 1

; 72   :       sb ^= y;

	xor	al, cl
	sub	edx, 1
	jne	SHORT $LL4@SubByte

; 73   :     }
; 74   :     return sb ^ 0x63;

	xor	al, 99					; 00000063H

; 75   : }

	ret	0
_SubByte ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\aes\aes_enc.c
;	COMDAT _gf_mulinv
_TEXT	SEGMENT
tv165 = 8						; size = 4
_x$ = 8							; size = 1
_gf_mulinv PROC						; COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 45   :     uint8_t y=x, i;

	mov	bl, BYTE PTR _x$[ebp]

; 46   : 
; 47   :     if (x) {

	test	bl, bl
	je	SHORT $LN6@gf_mulinv

; 48   :       // calculate logarithm gen 3
; 49   :       for (y=1, i=0; ;i++) {
; 50   :         y ^= gf_mul2 (y);

	push	1
	xor	bh, bh
	call	_gf_mul2
	pop	ecx
	mov	ecx, eax
	xor	cl, 1
	jmp	SHORT $LN20@gf_mulinv
$LL4@gf_mulinv:
	movzx	eax, cl
	inc	bh
	push	eax
	call	_gf_mul2
	pop	ecx
	mov	ecx, DWORD PTR tv165[ebp]
	xor	cl, al
$LN20@gf_mulinv:
	mov	DWORD PTR tv165[ebp], ecx

; 51   :         if (y==x) break;

	cmp	cl, bl
	jne	SHORT $LL4@gf_mulinv

; 54   :       // calculate anti-logarithm gen 3
; 55   :       for (y=1; i; i++) {

	mov	bl, 1
	add	bh, 2
	je	SHORT $LN6@gf_mulinv

; 52   :       }
; 53   :       i+=2;

	neg	bh
	push	esi
	movzx	esi, bh
$LL7@gf_mulinv:

; 56   :         y ^= gf_mul2(y);

	movzx	ecx, bl
	push	ecx
	call	_gf_mul2
	xor	bl, al
	pop	ecx
	sub	esi, 1
	jne	SHORT $LL7@gf_mulinv
	pop	esi
$LN6@gf_mulinv:

; 57   :       }
; 58   :     }
; 59   :     return y;

	mov	al, bl
	pop	ebx

; 60   : }

	pop	ebp
	ret	0
_gf_mulinv ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\aes\aes_enc.c
;	COMDAT _gf_mul2
_TEXT	SEGMENT
_w$ = 8							; size = 4
_gf_mul2 PROC						; COMDAT

; 36   :     uint32_t t = w & 0x80808080;

	mov	ecx, DWORD PTR _w$[esp-4]
	and	ecx, -2139062144			; 80808080H

; 37   :     
; 38   :     return ((w ^ t ) << 1) ^ (( t >> 7) * 0x0000001B);

	mov	eax, ecx
	shr	ecx, 7
	xor	eax, DWORD PTR _w$[esp-4]
	imul	ecx, ecx, 27
	add	eax, eax
	xor	eax, ecx

; 39   : }

	ret	0
_gf_mul2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\aes\aes_enc.c
;	COMDAT _aes_setkey
_TEXT	SEGMENT
_c$ = 8							; size = 4
_key$ = 12						; size = 4
_aes_setkey PROC					; COMDAT

; 155  :     int      i;
; 156  :     uint32_t x;
; 157  :     uint32_t *w=(uint32_t*)c->w;
; 158  :     uint32_t rcon=1;
; 159  : 
; 160  :     for (i=0; i<Nk; i++) {

	mov	edx, DWORD PTR _key$[esp-4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _c$[esp+8]
	xor	ebp, ebp
	push	edi
	push	8
	pop	ebx
	inc	ebp
	mov	ecx, esi
	sub	edx, esi
	mov	edi, ebx
$LL4@aes_setkey:

; 161  :       w[i]=((uint32_t*)key)[i];

	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR [ecx], eax
	lea	ecx, DWORD PTR [ecx+4]
	sub	edi, 1
	jne	SHORT $LL4@aes_setkey
$LL7@aes_setkey:

; 162  :     }
; 163  : 
; 164  :     for (i=Nk; i<Nb*(Nr+1); i++)
; 165  :     {
; 166  :       x = w[i-1];

	mov	edi, DWORD PTR [esi+28]

; 167  :       if ((i % Nk)==0) {

	mov	eax, ebx
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN21@aes_setkey
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN21@aes_setkey:
	jne	SHORT $LN8@aes_setkey

; 168  :         x = RotWord(x);

	ror	edi, 8

; 169  :         x = SubWord(x) ^ rcon;

	push	edi
	call	_SubWord
	mov	edi, eax

; 170  :         rcon=gf_mul2(rcon);

	push	ebp
	xor	edi, ebp
	call	_gf_mul2
	pop	ecx
	mov	ebp, eax
	jmp	SHORT $LN22@aes_setkey
$LN8@aes_setkey:

; 171  :       } else if ((Nk > 6) && ((i % Nk) == 4)) {

	cmp	eax, 4
	jne	SHORT $LN10@aes_setkey

; 172  :         x = SubWord(x);

	push	edi
	call	_SubWord
	mov	edi, eax
$LN22@aes_setkey:
	pop	ecx
$LN10@aes_setkey:

; 173  :       }
; 174  :       w[i] = w[i-Nk] ^ x;

	mov	ecx, DWORD PTR [esi]
	xor	ecx, edi
	inc	ebx
	mov	DWORD PTR [esi+32], ecx
	add	esi, 4
	cmp	ebx, 60					; 0000003cH
	jl	SHORT $LL7@aes_setkey

; 175  :     }
; 176  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
_aes_setkey ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\aes\aes_enc.c
;	COMDAT _aes_enc
_TEXT	SEGMENT
_c$ = 8							; size = 4
_s$ = 12						; size = 4
_aes_enc PROC						; COMDAT

; 181  : {

	push	esi

; 182  :     uint32_t r;
; 183  :     
; 184  :     AddRoundKey (c, s, 0);

	mov	esi, DWORD PTR _s$[esp]
	push	edi
	push	0
	push	esi
	push	DWORD PTR _c$[esp+12]
	call	_AddRoundKey

; 185  :     
; 186  :     for (r=1; r<Nr; r++) {

	xor	edi, edi
	add	esp, 12					; 0000000cH
	inc	edi
$LL4@aes_enc:

; 187  :       SBSR (s);

	push	esi
	call	_SBSR

; 188  :       MixColumns (s);

	push	esi
	call	_MixColumns

; 189  :       AddRoundKey (c, s, r);     

	push	edi
	push	esi
	push	DWORD PTR _c$[esp+20]
	call	_AddRoundKey
	add	esp, 20					; 00000014H
	inc	edi
	cmp	edi, 14					; 0000000eH
	jb	SHORT $LL4@aes_enc

; 190  :     }
; 191  :     SBSR (s);

	push	esi
	call	_SBSR

; 192  :     AddRoundKey (c, s, r);   

	push	edi
	push	esi
	push	DWORD PTR _c$[esp+16]
	call	_AddRoundKey
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 193  : }

	ret	0
_aes_enc ENDP
_TEXT	ENDS
END
