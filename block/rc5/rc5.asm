; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	c:\hub\tinycrypt\block\rc5\rc5.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_rc5_setkey
PUBLIC	_rc5_crypt
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\rc5\rc5.c
;	COMDAT _rc5_crypt
_TEXT	SEGMENT
_key$ = 8						; size = 4
_input$ = 12						; size = 4
_output$ = 16						; size = 4
_enc$ = 20						; size = 4
_rc5_crypt PROC						; COMDAT

; 67   :     rc5_blk *in, *out;
; 68   :     uint32_t *k=(uint32_t*)key->x;
; 69   :     uint32_t A, B, T, i;
; 70   :     
; 71   :     in  = input;
; 72   :     out = output;
; 73   :     
; 74   :     A = in->v32[0]; B = in->v32[1];
; 75   :     
; 76   :     if (enc==RC5_ENCRYPT) {

	cmp	DWORD PTR _enc$[esp-4], 1
	mov	eax, DWORD PTR _input$[esp-4]
	push	ebx
	push	esi
	mov	ebx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	jne	SHORT $LN5@rc5_crypt

; 77   :       A += *k; k++;

	mov	eax, DWORD PTR _key$[esp+4]
	add	ebx, DWORD PTR [eax]
	lea	esi, DWORD PTR [eax+4]

; 78   :       B += *k; k++;

	add	edx, DWORD PTR [esi]
	add	esi, 4

; 79   :     } else {

	jmp	SHORT $LN6@rc5_crypt
$LN5@rc5_crypt:

; 80   :       k += RC5_KR - 1;

	mov	esi, DWORD PTR _key$[esp+4]
	add	esi, 100				; 00000064H
$LN6@rc5_crypt:

; 81   :     }
; 82   :     
; 83   :     for (i=0; i<RC5_KR-2; i++)

	push	ebp
	push	24					; 00000018H
	pop	ebp
$LL4@rc5_crypt:

; 84   :     {
; 85   :       if (enc==RC5_ENCRYPT) {

	cmp	DWORD PTR _enc$[esp+8], 1
	jne	SHORT $LN7@rc5_crypt

; 86   :         A = ROTL32(A ^ B, B) + *k; k++;

	xor	ebx, edx
	movzx	ecx, dl
	rol	ebx, cl
	add	ebx, DWORD PTR [esi]
	add	esi, 4

; 87   :       } else {

	jmp	SHORT $LN8@rc5_crypt
$LN7@rc5_crypt:

; 88   :         B = ROTR32(B - *k, A) ^ A; k--;

	sub	edx, DWORD PTR [esi]
	mov	al, 32					; 00000020H
	sub	al, bl
	movzx	ecx, al
	rol	edx, cl
	xor	edx, ebx
	sub	esi, 4
$LN8@rc5_crypt:

; 89   :       }
; 90   :       // swap
; 91   :       T = B;

	mov	eax, edx

; 92   :       B = A;

	mov	edx, ebx

; 93   :       A = T;

	mov	ebx, eax
	sub	ebp, 1
	jne	SHORT $LL4@rc5_crypt

; 94   :     }
; 95   :     if (enc==RC5_DECRYPT) {

	cmp	DWORD PTR _enc$[esp+8], 0
	pop	ebp
	jne	SHORT $LN9@rc5_crypt

; 96   :       B -= *k; k--;

	sub	edx, DWORD PTR [esi]

; 97   :       A -= *k; k--;

	sub	ebx, DWORD PTR [esi-4]
$LN9@rc5_crypt:

; 98   :     }
; 99   :     out->v32[0] = A; out->v32[1] = B;

	mov	eax, DWORD PTR _output$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], edx
	pop	ebx

; 100  : }

	ret	0
_rc5_crypt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\block\rc5\rc5.c
;	COMDAT _rc5_setkey
_TEXT	SEGMENT
_A$2$ = -20						; size = 4
_L$ = -16						; size = 16
_key$ = 8						; size = 4
tv316 = 12						; size = 4
_input$ = 12						; size = 4
_rc5_setkey PROC					; COMDAT

; 33   : {  

	sub	esp, 20					; 00000014H

; 34   :     uint32_t i, j, k, A, B, L[4], *kptr=(uint32_t*)input; 
; 35   :     
; 36   :     // initialize L with key
; 37   :     for (i=0; i<4; i++) {
; 38   :       L[i] = kptr[i];
; 39   :     }
; 40   :     
; 41   :     A=RC5_P;

	mov	ecx, -1209970333			; b7e15163H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _input$[esp+28]
	push	edi
	lea	edi, DWORD PTR _L$[esp+36]

; 42   :     
; 43   :     // initialize S with constants
; 44   :     for (i=0; i<RC5_KR; i++) {

	push	26					; 0000001aH
	movsd
	pop	edx
	movsd
	movsd
	movsd
	mov	edi, DWORD PTR _key$[esp+32]
	xor	esi, esi
	mov	eax, esi
$LL18@rc5_setkey:

; 45   :       key->x[i] = A;

	mov	DWORD PTR [edi+eax*4], ecx

; 46   :       A += RC5_Q;

	sub	ecx, 1640531527				; 61c88647H
	inc	eax
	cmp	eax, edx
	jb	SHORT $LL18@rc5_setkey

; 47   :     }
; 48   :     
; 49   :     A=B=i=j=k=0;

	mov	ebp, esi
	mov	DWORD PTR tv316[esp+32], 78		; 0000004eH
	mov	ebx, esi
	mov	ecx, esi
$LL10@rc5_setkey:

; 50   :     
; 51   :     // mix with key
; 52   :     for (; k < RC5_KR*3; k++)
; 53   :     { 
; 54   :       A = key->x[i] = ROTL32(key->x[i] + A+B, 3);  

	mov	edx, DWORD PTR [edi+ebp*4]
	add	edx, ebx
	add	edx, ecx
	rol	edx, 3
	mov	DWORD PTR _A$2$[esp+36], edx
	mov	DWORD PTR [edi+ebp*4], edx

; 55   :       B = L[j]      = ROTL32(L[j] + A+B, A+B);
; 56   :       
; 57   :       i++;
; 58   :       i %= RC5_KR;

	push	26					; 0000001aH
	lea	eax, DWORD PTR [ebx+edx]
	add	ebx, DWORD PTR _L$[esp+esi*4+40]
	add	ebx, edx
	movzx	ecx, al
	rol	ebx, cl
	lea	eax, DWORD PTR [ebp+1]
	xor	edx, edx
	mov	DWORD PTR _L$[esp+esi*4+40], ebx
	pop	ecx
	div	ecx
	mov	ecx, DWORD PTR _A$2$[esp+36]

; 59   :       
; 60   :       j++;

	inc	esi

; 61   :       j %= RC5_KEYLEN/4;

	and	esi, 3
	mov	ebp, edx
	sub	DWORD PTR tv316[esp+32], 1
	jne	SHORT $LL10@rc5_setkey
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 62   :     } 
; 63   : }

	add	esp, 20					; 00000014H
	ret	0
_rc5_setkey ENDP
_TEXT	ENDS
END
