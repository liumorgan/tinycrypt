; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	c:\hub\chacha\cc20.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_cc20_setkey
PUBLIC	_cc20_encrypt
PUBLIC	_chacha_permute
PUBLIC	_cc20_stream
; Function compile flags: /Ogspy
; File c:\hub\chacha\cc20.c
;	COMDAT _cc20_stream
_TEXT	SEGMENT
tv382 = -20						; size = 4
_idx16$ = -16						; size = 16
_c$ = 8							; size = 4
_x$ = 12						; size = 4
_cc20_stream PROC					; COMDAT

; 82   : {

	sub	esp, 20					; 00000014H
	push	esi

; 83   :     int i, j;
; 84   : 
; 85   :     // 16-bit integers of each index
; 86   :     uint16_t idx16[8]=

	mov	esi, DWORD PTR _x$[esp+20]
	mov	ecx, esi
	push	edi

; 87   :     { 0xC840, 0xD951, 0xEA62, 0xFB73, 
; 88   :       0xFA50, 0xCB61, 0xD872, 0xE943 };
; 89   :     
; 90   :     // copy state to x
; 91   :     for (i=0; i<16; i++) { 

	mov	edi, DWORD PTR _c$[esp+24]
	sub	edi, esi
	mov	DWORD PTR _idx16$[esp+28], -648951744	; d951c840H
	push	16					; 00000010H
	mov	DWORD PTR _idx16$[esp+36], -76289438	; fb73ea62H
	mov	DWORD PTR _idx16$[esp+40], -882771376	; cb61fa50H
	mov	DWORD PTR _idx16$[esp+44], -381429646	; e943d872H
	mov	DWORD PTR tv382[esp+32], edi
	pop	edx
$LL23@cc20_strea:

; 92   :       x->w[i] = c->s.w[i];

	mov	eax, DWORD PTR [edi+ecx]
	mov	DWORD PTR [ecx], eax
	lea	ecx, DWORD PTR [ecx+4]
	sub	edx, 1
	jne	SHORT $LL23@cc20_strea

; 93   :     }
; 94   :     // apply 20 rounds
; 95   :     for (i=0; i<20; i+=2) {

	mov	edi, DWORD PTR _c$[esp+24]
	push	ebx
	push	ebp
	push	10					; 0000000aH
	pop	ebp
$LL7@cc20_strea:

; 96   :       for (j=0; j<8; j++) {

	xor	ebx, ebx
$LL10@cc20_strea:

; 97   :         chacha_permute(x, idx16[j]);

	movzx	eax, WORD PTR _idx16$[esp+ebx*2+36]
	push	eax
	push	esi
	call	_chacha_permute
	inc	ebx
	pop	ecx
	pop	ecx
	cmp	ebx, 8
	jl	SHORT $LL10@cc20_strea

; 93   :     }
; 94   :     // apply 20 rounds
; 95   :     for (i=0; i<20; i+=2) {

	sub	ebp, 1
	jne	SHORT $LL7@cc20_strea
	mov	edx, DWORD PTR tv382[esp+36]
	push	16					; 00000010H
	pop	ecx
	pop	ebp
	pop	ebx
$LL25@cc20_strea:

; 98   :       }
; 99   :     }
; 100  :     // add state to x
; 101  :     for (i=0; i<16; i++) {
; 102  :       x->w[i] += c->s.w[i];

	mov	eax, DWORD PTR [esi+edx]
	add	DWORD PTR [esi], eax
	lea	esi, DWORD PTR [esi+4]
	sub	ecx, 1
	jne	SHORT $LL25@cc20_strea

; 103  :     }
; 104  :     // update block counter
; 105  :     c->s.q[6]++;

	add	DWORD PTR [edi+48], 1
	adc	DWORD PTR [edi+52], ecx
	pop	edi
	pop	esi

; 106  :     // stopping at 2^70 bytes per nonce is user's responsibility
; 107  : }

	add	esp, 20					; 00000014H
	ret	0
_cc20_stream ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\chacha\cc20.c
;	COMDAT _chacha_permute
_TEXT	SEGMENT
_blk$ = 8						; size = 4
_idx$ = 12						; size = 2
_chacha_permute PROC					; COMDAT

; 59   :     uint32_t a, b, c, d;
; 60   :     uint32_t *x=(uint32_t*)&blk->b;
; 61   :     
; 62   :     a = (idx         & 0xF);
; 63   :     b = ((idx >>  4) & 0xF);
; 64   :     c = ((idx >>  8) & 0xF);
; 65   :     d = ((idx >> 12) & 0xF);
; 66   :     
; 67   :     x[a] = x[a] + x[b]; 

	mov	ecx, DWORD PTR _blk$[esp-4]
	push	ebx
	movzx	ebx, WORD PTR _idx$[esp]
	push	esi
	push	edi
	mov	edi, ebx
	mov	esi, ebx
	and	esi, 15					; 0000000fH
	shr	edi, 4
	and	edi, 15					; 0000000fH
	mov	edx, ebx
	shr	ebx, 12					; 0000000cH
	shr	edx, 8
	and	edx, 15					; 0000000fH
	mov	eax, DWORD PTR [ecx+edi*4]
	add	DWORD PTR [ecx+esi*4], eax

; 68   :     x[d] = ROTL32(x[d] ^ x[a],16);

	mov	eax, DWORD PTR [ecx+ebx*4]
	xor	eax, DWORD PTR [ecx+esi*4]
	rol	eax, 16					; 00000010H
	mov	DWORD PTR [ecx+ebx*4], eax

; 69   :     
; 70   :     x[c] = x[c] + x[d]; 

	add	DWORD PTR [ecx+edx*4], eax

; 71   :     x[b] = ROTL32(x[b] ^ x[c],12);

	mov	eax, DWORD PTR [ecx+edi*4]
	xor	eax, DWORD PTR [ecx+edx*4]
	rol	eax, 12					; 0000000cH
	mov	DWORD PTR [ecx+edi*4], eax

; 72   :     
; 73   :     x[a] = x[a] + x[b]; 

	add	DWORD PTR [ecx+esi*4], eax

; 74   :     x[d] = ROTL32(x[d] ^ x[a], 8);

	mov	eax, DWORD PTR [ecx+esi*4]
	xor	eax, DWORD PTR [ecx+ebx*4]
	rol	eax, 8
	mov	DWORD PTR [ecx+ebx*4], eax

; 75   :     
; 76   :     x[c] = x[c] + x[d]; 

	add	DWORD PTR [ecx+edx*4], eax

; 77   :     x[b] = ROTL32(x[b] ^ x[c], 7);

	mov	eax, DWORD PTR [ecx+edi*4]
	xor	eax, DWORD PTR [ecx+edx*4]
	rol	eax, 7
	mov	DWORD PTR [ecx+edi*4], eax
	pop	edi
	pop	esi
	pop	ebx

; 78   : }

	ret	0
_chacha_permute ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\chacha\cc20.c
;	COMDAT _cc20_encrypt
_TEXT	SEGMENT
_stream$ = -64						; size = 64
_len$ = 8						; size = 4
_in$ = 12						; size = 4
_ctx$ = 16						; size = 4
_cc20_encrypt PROC					; COMDAT

; 111  : {

	sub	esp, 64					; 00000040H
	push	esi

; 112  :     uint32_t i, r;
; 113  :     cc20_blk stream;
; 114  :     uint8_t  *p=(uint8_t*)in;
; 115  :     
; 116  :     while (len) {      

	mov	esi, DWORD PTR _len$[esp+64]
	push	edi
	mov	edi, DWORD PTR _in$[esp+68]
	test	esi, esi
	je	SHORT $LN3@cc20_encry
	push	ebx
	push	ebp
	push	64					; 00000040H
	pop	ebx
$LL2@cc20_encry:

; 117  :       cc20_stream(ctx, &stream);

	lea	eax, DWORD PTR _stream$[esp+80]
	push	eax
	push	DWORD PTR _ctx$[esp+80]
	call	_cc20_stream
	pop	ecx
	pop	ecx

; 118  :       
; 119  :       r=(len>64) ? 64 : len;

	cmp	esi, ebx
	mov	ecx, esi
	cmova	ecx, ebx

; 120  :       
; 121  :       // xor input with stream
; 122  :       for (i=0; i<r; i++) {

	test	ecx, ecx
	je	SHORT $LN5@cc20_encry
	lea	ebx, DWORD PTR _stream$[esp+80]
	mov	edx, edi
	sub	ebx, edi
	mov	ebp, ecx
$LL12@cc20_encry:

; 123  :         p[i] ^= stream.b[i];

	mov	al, BYTE PTR [ebx+edx]
	xor	BYTE PTR [edx], al
	inc	edx
	sub	ebp, 1
	jne	SHORT $LL12@cc20_encry
	push	64					; 00000040H
	pop	ebx
$LN5@cc20_encry:

; 124  :       }
; 125  :     
; 126  :       len -= r;
; 127  :       p += r;

	add	edi, ecx
	sub	esi, ecx
	jne	SHORT $LL2@cc20_encry
	pop	ebp
	pop	ebx
$LN3@cc20_encry:
	pop	edi
	pop	esi

; 128  :     }
; 129  : }

	add	esp, 64					; 00000040H
	ret	0
_cc20_encrypt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\chacha\cc20.c
;	COMDAT _cc20_setkey
_TEXT	SEGMENT
_c$ = 8							; size = 4
_key$ = 12						; size = 4
_nonce$ = 16						; size = 4
_cc20_setkey PROC					; COMDAT

; 35   :     cc20_blk *iv=(cc20_blk*)nonce;
; 36   :     int      i;
; 37   :     
; 38   :     // "expand 32-byte k"
; 39   :     c->s.w[0] = 0x61707865;

	mov	edx, DWORD PTR _c$[esp-4]

; 40   :     c->s.w[1] = 0x3320646E;
; 41   :     c->s.w[2] = 0x79622D32;
; 42   :     c->s.w[3] = 0x6B206574;
; 43   : 
; 44   :     // copy 256-bit key
; 45   :     for (i=0; i<32; i++) {

	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _key$[esp]
	mov	DWORD PTR [edx], 1634760805		; 61707865H
	mov	DWORD PTR [edx+4], 857760878		; 3320646eH
	mov	DWORD PTR [edx+8], 2036477234		; 79622d32H
	mov	DWORD PTR [edx+12], 1797285236		; 6b206574H
$LL8@cc20_setke:

; 46   :       c->s.b[16+i] = ((uint8_t*)key)[i];

	mov	al, BYTE PTR [ecx+esi]
	mov	BYTE PTR [edx+ecx+16], al
	inc	ecx
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LL8@cc20_setke

; 47   :     }
; 48   :     
; 49   :     // set 64-bit block counter and 64-bit nonce/iv
; 50   :     c->s.w[12] = 0;
; 51   :     c->s.w[13] = 0;
; 52   :     c->s.w[14] = iv->w[0];

	mov	ecx, DWORD PTR _nonce$[esp]
	and	DWORD PTR [edx+48], 0
	and	DWORD PTR [edx+52], 0
	pop	esi
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+56], eax

; 53   :     c->s.w[15] = iv->w[1];

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+60], eax

; 54   : }

	ret	0
_cc20_setkey ENDP
_TEXT	ENDS
END
