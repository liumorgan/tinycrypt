; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	c:\hub\tinycrypt\hash\md5\md5.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_MD5_Init
PUBLIC	_MD5_Update
PUBLIC	_MD5_Final
PUBLIC	_MD5_Transform
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\hash\md5\md5.c
;	COMDAT _MD5_Transform
_TEXT	SEGMENT
_rotf$ = -348						; size = 4
_rotg$ = -344						; size = 4
_roth$ = -340						; size = 4
_roti$ = -336						; size = 4
_sigma$ = -332						; size = 64
_a$1$ = -268						; size = 4
_b$1$ = -264						; size = 4
tv856 = -260						; size = 4
_tc$ = -256						; size = 256
_ctx$ = 8						; size = 4
_MD5_Transform PROC					; COMDAT

; 57   : {

	sub	esp, 348				; 0000015cH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 58   :     uint32_t a, b, c, d, i, t, s;
; 59   :     uint8_t rotf[]={7,12,17,22};

	mov	DWORD PTR _rotf$[esp+364], 370215943	; 16110c07H

; 60   :     uint8_t rotg[]={5, 9,14,20};
; 61   :     uint8_t roth[]={4,11,16,23};
; 62   :     uint8_t roti[]={6,10,15,21};
; 63   : 
; 64   :     uint8_t sigma[]=

	xor	ebx, ebx
	mov	DWORD PTR _rotg$[esp+364], 336464133	; 140e0905H
	mov	DWORD PTR _roth$[esp+364], 386927364	; 17100b04H
	mov	DWORD PTR _roti$[esp+364], 353307142	; 150f0a06H
	mov	DWORD PTR _sigma$[esp+364], 50462976	; 03020100H
	mov	DWORD PTR _sigma$[esp+368], 117835012	; 07060504H
	mov	DWORD PTR _sigma$[esp+372], 185207048	; 0b0a0908H
	mov	DWORD PTR _sigma$[esp+376], 252579084	; 0f0e0d0cH
	mov	DWORD PTR _sigma$[esp+380], 722433	; 000b0601H
	mov	DWORD PTR _sigma$[esp+384], 68094469	; 040f0a05H
	mov	DWORD PTR _sigma$[esp+388], 134417929	; 08030e09H
	mov	DWORD PTR _sigma$[esp+392], 201785869	; 0c07020dH
	mov	DWORD PTR _sigma$[esp+396], 235603973	; 0e0b0805H
	mov	DWORD PTR _sigma$[esp+400], 168231937	; 0a070401H
	mov	DWORD PTR _sigma$[esp+404], 100859917	; 0603000dH
	mov	DWORD PTR _sigma$[esp+408], 34540553	; 020f0c09H
	mov	DWORD PTR _sigma$[esp+412], 84805376	; 050e0700H
	mov	DWORD PTR _sigma$[esp+416], 17433356	; 010a030cH
	mov	DWORD PTR _sigma$[esp+420], 218500872	; 0d060f08H
	mov	DWORD PTR _sigma$[esp+424], 151128836	; 09020b04H

; 65   :     { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
; 66   :       1,6,11,0,5,10,15,4,9,14,3,8,13,2,7,12,
; 67   :       5,8,11,14,1,4,7,10,13,0,3,6,9,12,15,2,
; 68   :       0,7,14,5,12,3,10,1,8,15,6,13,4,11,2,9 };
; 69   :     
; 70   :   #ifndef DYNAMIC
; 71   :   uint32_t tc[64] =

	mov	DWORD PTR _tc$[esp+364], -680876936	; d76aa478H
	mov	DWORD PTR _tc$[esp+368], -389564586	; e8c7b756H
	mov	DWORD PTR _tc$[esp+372], 606105819	; 242070dbH
	mov	DWORD PTR _tc$[esp+376], -1044525330	; c1bdceeeH
	mov	DWORD PTR _tc$[esp+380], -176418897	; f57c0fafH
	mov	DWORD PTR _tc$[esp+384], 1200080426	; 4787c62aH
	mov	DWORD PTR _tc$[esp+388], -1473231341	; a8304613H
	mov	DWORD PTR _tc$[esp+392], -45705983	; fd469501H
	mov	DWORD PTR _tc$[esp+396], 1770035416	; 698098d8H
	mov	DWORD PTR _tc$[esp+400], -1958414417	; 8b44f7afH
	mov	DWORD PTR _tc$[esp+404], -42063		; ffff5bb1H
	mov	DWORD PTR _tc$[esp+408], -1990404162	; 895cd7beH
	mov	DWORD PTR _tc$[esp+412], 1804603682	; 6b901122H
	mov	DWORD PTR _tc$[esp+416], -40341101	; fd987193H
	mov	DWORD PTR _tc$[esp+420], -1502002290	; a679438eH
	mov	DWORD PTR _tc$[esp+424], 1236535329	; 49b40821H
	mov	DWORD PTR _tc$[esp+428], -165796510	; f61e2562H
	mov	DWORD PTR _tc$[esp+432], -1069501632	; c040b340H
	mov	DWORD PTR _tc$[esp+436], 643717713	; 265e5a51H
	mov	DWORD PTR _tc$[esp+440], -373897302	; e9b6c7aaH
	mov	DWORD PTR _tc$[esp+444], -701558691	; d62f105dH
	mov	DWORD PTR _tc$[esp+448], 38016083	; 02441453H
	mov	DWORD PTR _tc$[esp+452], -660478335	; d8a1e681H
	mov	DWORD PTR _tc$[esp+456], -405537848	; e7d3fbc8H
	mov	DWORD PTR _tc$[esp+460], 568446438	; 21e1cde6H
	mov	DWORD PTR _tc$[esp+464], -1019803690	; c33707d6H
	mov	DWORD PTR _tc$[esp+468], -187363961	; f4d50d87H
	mov	DWORD PTR _tc$[esp+472], 1163531501	; 455a14edH
	mov	DWORD PTR _tc$[esp+476], -1444681467	; a9e3e905H
	mov	DWORD PTR _tc$[esp+480], -51403784	; fcefa3f8H
	mov	DWORD PTR _tc$[esp+484], 1735328473	; 676f02d9H
	mov	DWORD PTR _tc$[esp+488], -1926607734	; 8d2a4c8aH
	mov	DWORD PTR _tc$[esp+492], -378558	; fffa3942H
	mov	DWORD PTR _tc$[esp+496], -2022574463	; 8771f681H
	mov	DWORD PTR _tc$[esp+500], 1839030562	; 6d9d6122H
	mov	DWORD PTR _tc$[esp+504], -35309556	; fde5380cH
	mov	DWORD PTR _tc$[esp+508], -1530992060	; a4beea44H
	mov	DWORD PTR _tc$[esp+512], 1272893353	; 4bdecfa9H
	mov	DWORD PTR _tc$[esp+516], -155497632	; f6bb4b60H
	mov	DWORD PTR _tc$[esp+520], -1094730640	; bebfbc70H
	mov	DWORD PTR _tc$[esp+524], 681279174	; 289b7ec6H
	mov	DWORD PTR _tc$[esp+528], -358537222	; eaa127faH
	mov	DWORD PTR _tc$[esp+532], -722521979	; d4ef3085H
	mov	DWORD PTR _tc$[esp+536], 76029189	; 04881d05H
	mov	DWORD PTR _tc$[esp+540], -640364487	; d9d4d039H
	mov	DWORD PTR _tc$[esp+544], -421815835	; e6db99e5H
	mov	DWORD PTR _tc$[esp+548], 530742520	; 1fa27cf8H
	mov	DWORD PTR _tc$[esp+552], -995338651	; c4ac5665H
	mov	DWORD PTR _tc$[esp+556], -198630844	; f4292244H
	mov	DWORD PTR _tc$[esp+560], 1126891415	; 432aff97H
	mov	DWORD PTR _tc$[esp+564], -1416354905	; ab9423a7H
	mov	DWORD PTR _tc$[esp+568], -57434055	; fc93a039H
	mov	DWORD PTR _tc$[esp+572], 1700485571	; 655b59c3H
	mov	DWORD PTR _tc$[esp+576], -1894986606	; 8f0ccc92H
	mov	DWORD PTR _tc$[esp+580], -1051523	; ffeff47dH
	mov	DWORD PTR _tc$[esp+584], -2054922799	; 85845dd1H

; 72   :   { 0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE, 
; 73   :     0xF57C0FAF, 0x4787C62A, 0xA8304613, 0xFD469501,
; 74   :     0x698098D8, 0x8B44F7AF, 0xFFFF5BB1, 0x895CD7BE,
; 75   :     0x6B901122, 0xFD987193, 0xA679438E, 0x49B40821,
; 76   :     0xF61E2562, 0xC040B340, 0x265E5A51, 0xE9B6C7AA,
; 77   :     0xD62F105D, 0x02441453, 0xD8A1E681, 0xE7D3FBC8,
; 78   :     0x21E1CDE6, 0xC33707D6, 0xF4D50D87, 0x455A14ED,
; 79   :     0xA9E3E905, 0xFCEFA3F8, 0x676F02D9, 0x8D2A4C8A,
; 80   :     0xFFFA3942, 0x8771F681, 0x6D9D6122, 0xFDE5380C,
; 81   :     0xA4BEEA44, 0x4BDECFA9, 0xF6BB4B60, 0xBEBFBC70,
; 82   :     0x289B7EC6, 0xEAA127FA, 0xD4EF3085, 0x04881D05,
; 83   :     0xD9D4D039, 0xE6DB99E5, 0x1FA27CF8, 0xC4AC5665,
; 84   :     0xF4292244, 0x432AFF97, 0xAB9423A7, 0xFC93A039,
; 85   :     0x655B59C3, 0x8F0CCC92, 0xFFEFF47D, 0x85845DD1,
; 86   :     0x6FA87E4F, 0xFE2CE6E0, 0xA3014314, 0x4E0811A1,
; 87   :     0xF7537E82, 0xBD3AF235, 0x2AD7D2BB, 0xEB86D391 };
; 88   :   #endif  
; 89   :     
; 90   :     a = ctx->s.w[0];

	mov	esi, DWORD PTR _ctx$[esp+360]
	mov	DWORD PTR _tc$[esp+588], 1873313359	; 6fa87e4fH
	mov	DWORD PTR _tc$[esp+592], -30611744	; fe2ce6e0H
	mov	DWORD PTR _tc$[esp+596], -1560198380	; a3014314H
	mov	eax, DWORD PTR [esi]

; 91   :     b = ctx->s.w[1];
; 92   :     c = ctx->s.w[2];

	mov	edi, DWORD PTR [esi+8]

; 93   :     d = ctx->s.w[3];

	mov	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR tv856[esp+364], eax
	mov	DWORD PTR _a$1$[esp+364], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _tc$[esp+600], 1309151649	; 4e0811a1H
	mov	DWORD PTR _tc$[esp+604], -145523070	; f7537e82H
	mov	DWORD PTR _tc$[esp+608], -1120210379	; bd3af235H
	mov	DWORD PTR _tc$[esp+612], 718787259	; 2ad7d2bbH
	mov	DWORD PTR _tc$[esp+616], -343485551	; eb86d391H
	mov	DWORD PTR _b$1$[esp+364], eax
	jmp	SHORT $LN4@MD5_Transf
$LL16@MD5_Transf:
	mov	esi, DWORD PTR _ctx$[esp+360]
$LN4@MD5_Transf:

; 94   :     
; 95   :     for (i=0; i<64; i++) {
; 96   :       #ifdef DYNAMIC
; 97   :         t=tc(i+1);
; 98   :       #else
; 99   :         t=tc[i];
; 100  :       #endif
; 101  :       if (i < 16) {

	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN5@MD5_Transf

; 102  :         s = rotf[i%4];
; 103  :         a += F (b, c, d);

	mov	edx, ebp
	xor	edx, edi
	and	edx, eax
	mov	eax, ebx
	xor	edx, ebp
	and	eax, 3
	lea	eax, DWORD PTR _rotf$[esp+eax+364]
	jmp	SHORT $LN10@MD5_Transf
$LN5@MD5_Transf:

; 104  :       } else if (i < 32) {

	cmp	ebx, 32					; 00000020H
	jae	SHORT $LN7@MD5_Transf

; 105  :         s = rotg[i%4];
; 106  :         a += G (b, c, d);

	mov	edx, edi
	xor	edx, eax
	mov	eax, ebx
	and	edx, ebp
	xor	edx, edi
	and	eax, 3
	lea	eax, DWORD PTR _rotg$[esp+eax+364]
	jmp	SHORT $LN10@MD5_Transf
$LN7@MD5_Transf:

; 107  :       } else if (i < 48) {
; 108  :         s = roth[i%4];
; 109  :         a += H (b, c, d);

	mov	edx, ebp
	cmp	ebx, 48					; 00000030H
	jae	SHORT $LN9@MD5_Transf
	xor	edx, edi
	xor	edx, eax
	mov	eax, ebx
	and	eax, 3
	lea	eax, DWORD PTR _roth$[esp+eax+364]

; 110  :       } else {

	jmp	SHORT $LN10@MD5_Transf
$LN9@MD5_Transf:

; 111  :         s = roti[i%4];
; 112  :         a += I (b, c, d);

	not	edx
	or	edx, eax
	mov	eax, ebx
	xor	edx, edi
	and	eax, 3
	lea	eax, DWORD PTR _roti$[esp+eax+364]
$LN10@MD5_Transf:

; 113  :       }
; 114  :       a += ctx->buf.w[sigma[i]] + t;

	movzx	ecx, BYTE PTR [eax]
	movzx	eax, BYTE PTR _sigma$[esp+ebx+364]
	mov	esi, DWORD PTR [esi+eax*4+16]
	add	esi, edx
	add	esi, DWORD PTR _tc$[esp+ebx*4+364]
	add	esi, DWORD PTR _a$1$[esp+364]

; 115  :       a = ROTL32(a, s);

	rol	esi, cl

; 116  :       a += b;
; 117  :       t=a;
; 118  :       a=d;

	mov	ecx, ebp
	add	esi, DWORD PTR _b$1$[esp+364]
	inc	ebx
	mov	DWORD PTR _a$1$[esp+364], ebp

; 119  :       d=c;

	mov	ebp, edi

; 120  :       c=b;

	mov	edi, DWORD PTR _b$1$[esp+364]

; 121  :       b=t;

	mov	eax, esi
	mov	DWORD PTR _b$1$[esp+364], eax
	cmp	ebx, 64					; 00000040H
	jb	$LL16@MD5_Transf

; 122  :     }
; 123  : 
; 124  :     ctx->s.w[0] += a;

	mov	eax, DWORD PTR tv856[esp+364]
	add	eax, ecx
	mov	ecx, DWORD PTR _ctx$[esp+360]

; 125  :     ctx->s.w[1] += b;
; 126  :     ctx->s.w[2] += c;

	add	DWORD PTR [ecx+8], edi
	add	DWORD PTR [ecx+4], esi

; 127  :     ctx->s.w[3] += d;

	add	DWORD PTR [ecx+12], ebp
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx], eax
	pop	ebx

; 128  : }

	add	esp, 348				; 0000015cH
	ret	0
_MD5_Transform ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\hash\md5\md5.c
;	COMDAT _MD5_Final
_TEXT	SEGMENT
_dgst$ = 8						; size = 4
_c$ = 12						; size = 4
_MD5_Final PROC						; COMDAT

; 178  : {

	push	ebx

; 179  :     // see what length we have ere..
; 180  :     uint32_t len=c->len & (MD5_CBLOCK - 1);

	mov	ebx, DWORD PTR _c$[esp]
	push	esi
	push	edi

; 181  :     
; 182  :     memset (&c->buf.b[len], 0, MD5_CBLOCK - len);

	push	64					; 00000040H
	mov	edi, DWORD PTR [ebx+80]
	lea	esi, DWORD PTR [ebx+16]
	pop	eax
	and	edi, 63					; 0000003fH
	sub	eax, edi
	add	esi, edi
	push	eax
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 183  :     // add the end bit
; 184  :     c->buf.b[len] = 0x80;

	mov	BYTE PTR [esi], 128			; 00000080H

; 185  :     // if exceeding 56 bytes, transform it
; 186  :     if (len >= 56) {

	cmp	edi, 56					; 00000038H
	jb	SHORT $LN2@MD5_Final

; 187  :       MD5_Transform (c);

	push	ebx
	call	_MD5_Transform

; 188  :       memset (c->buf.b, 0, MD5_CBLOCK);

	push	64					; 00000040H
	lea	eax, DWORD PTR [ebx+16]
	push	0
	push	eax
	call	_memset
	add	esp, 16					; 00000010H
$LN2@MD5_Final:

; 189  :     }
; 190  :     // add total bits
; 191  :     c->buf.q[7] = c->len * 8;

	mov	eax, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR [ebx+84]
	shld	ecx, eax, 3

; 192  :     // compress
; 193  :     MD5_Transform(c);

	push	ebx
	shl	eax, 3
	mov	DWORD PTR [ebx+72], eax
	mov	DWORD PTR [ebx+76], ecx
	call	_MD5_Transform

; 194  :     // copy digest to buffer
; 195  :     memcpy (dgst, c->s.b, MD5_DIGEST_LENGTH);

	mov	edi, DWORD PTR _dgst$[esp+12]
	mov	esi, ebx
	pop	ecx
	movsd
	movsd
	movsd
	movsd
	pop	edi
	pop	esi
	pop	ebx

; 196  : }

	ret	0
_MD5_Final ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\hash\md5\md5.c
;	COMDAT _MD5_Update
_TEXT	SEGMENT
_c$ = 8							; size = 4
_in$ = 12						; size = 4
_len$ = 16						; size = 4
_MD5_Update PROC					; COMDAT

; 148  : void MD5_Update (MD5_CTX* c, void *in, uint32_t len) {

	push	esi

; 149  :     uint8_t *p = (uint8_t*)in;
; 150  :     uint32_t  r, idx;
; 151  :     
; 152  :     if (len==0) return;

	mov	esi, DWORD PTR _len$[esp]
	test	esi, esi
	je	SHORT $LN12@MD5_Update

; 153  :     
; 154  :     // get buffer index
; 155  :     idx = c->len & (MD5_CBLOCK - 1);

	push	ebp
	push	edi
	mov	edi, DWORD PTR _c$[esp+8]
	mov	ebp, DWORD PTR [edi+80]
	and	ebp, 63					; 0000003fH

; 156  :     
; 157  :     // update length
; 158  :     c->len += len;

	add	DWORD PTR [edi+80], esi
	adc	DWORD PTR [edi+84], 0

; 159  :     
; 160  :     while (len > 0) {

	test	esi, esi
	je	SHORT $LN13@MD5_Update
	mov	eax, DWORD PTR _in$[esp+8]
	push	ebx
$LL2@MD5_Update:

; 161  :       r = MIN(len, (MD5_CBLOCK - idx));

	push	64					; 00000040H
	pop	ebx
	sub	ebx, ebp
	cmp	esi, ebx
	cmovb	ebx, esi

; 162  :       memcpy (&c->buf.b[idx], p, r);

	push	ebx
	push	eax
	lea	eax, DWORD PTR [edi+16]
	add	eax, ebp
	push	eax
	call	_memcpy

; 163  :       if ((idx + r) < MD5_CBLOCK) break;

	lea	eax, DWORD PTR [ebx+ebp]
	add	esp, 12					; 0000000cH
	cmp	eax, 64					; 00000040H
	jb	SHORT $LN15@MD5_Update

; 164  :       
; 165  :       MD5_Transform (c);

	push	edi
	call	_MD5_Transform

; 166  :       len -= r;
; 167  :       idx = 0;
; 168  :       p += r;

	mov	eax, DWORD PTR _in$[esp+16]
	xor	ebp, ebp
	add	eax, ebx
	mov	DWORD PTR _in$[esp+16], eax
	pop	ecx
	sub	esi, ebx
	jne	SHORT $LL2@MD5_Update
$LN15@MD5_Update:
	pop	ebx
$LN13@MD5_Update:
	pop	edi
	pop	ebp
$LN12@MD5_Update:
	pop	esi

; 169  :     }
; 170  : }

	ret	0
_MD5_Update ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\hash\md5\md5.c
;	COMDAT _MD5_Init
_TEXT	SEGMENT
_c$ = 8							; size = 4
_MD5_Init PROC						; COMDAT

; 136  :     c->len    = 0;

	mov	eax, DWORD PTR _c$[esp-4]
	and	DWORD PTR [eax+80], 0
	and	DWORD PTR [eax+84], 0

; 137  :     c->s.w[0] = 0x67452301;

	mov	DWORD PTR [eax], 1732584193		; 67452301H

; 138  :     c->s.w[1] = 0xefcdab89;

	mov	DWORD PTR [eax+4], -271733879		; efcdab89H

; 139  :     c->s.w[2] = 0x98badcfe;

	mov	DWORD PTR [eax+8], -1732584194		; 98badcfeH

; 140  :     c->s.w[3] = 0x10325476;

	mov	DWORD PTR [eax+12], 271733878		; 10325476H

; 141  : }

	ret	0
_MD5_Init ENDP
_TEXT	ENDS
END
