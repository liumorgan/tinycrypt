; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	c:\hub\tinycrypt\hash\md4\md4.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_MD4_Transform
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\hash\md4\md4.c
;	COMDAT _MD4_Transform
_TEXT	SEGMENT
_idxh$ = -60						; size = 16
_idxg$ = -44						; size = 16
_s$ = -28						; size = 16
_roth$ = -12						; size = 4
_rotg$ = -8						; size = 4
_rotf$ = -4						; size = 4
_c$ = 8							; size = 4
_MD4_Transform PROC					; COMDAT

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 43   :   uint32_t i, t;
; 44   :   uint32_t s[4];
; 45   :   
; 46   :   // increment by 4
; 47   :   uint8_t rotf[] = { 3, 7, 11, 19 };
; 48   :   uint8_t rotg[] = { 3, 5,  9, 13 };
; 49   :   uint8_t roth[] = { 3, 9, 11, 15 };
; 50   : 
; 51   :   // increment by 4 mod 15
; 52   :   uint8_t idxg[] = 
; 53   :   { 0, 4,  8, 12, 
; 54   :     1, 5,  9, 13, 
; 55   :     2, 6, 10, 14,  
; 56   :     3, 7, 11, 15 };
; 57   :     
; 58   :   // increment by 8 mod 12, 18, 12, 21
; 59   :   uint8_t idxh[] = 
; 60   :   { 0,  8, 4, 12, 
; 61   :     2, 10, 6, 14, 
; 62   :     1,  9, 5, 13,  
; 63   :     3, 11, 7, 15 };
; 64   : 
; 65   :   for (i=0; i<4; i++) {
; 66   :     s[i]=c->s.w[i];

	mov	edx, DWORD PTR _c$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	esi, edx
	lea	edi, DWORD PTR _s$[ebp]
	movsd
	movsd
	movsd
	movsd

; 67   :   }
; 68   :   
; 69   :   // for 48 rounds
; 70   :   for (i=0; i<48; i++) {

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _rotf$[ebp], 319489795	; 130b0703H
	mov	DWORD PTR _rotg$[ebp], 218694915	; 0d090503H
	mov	DWORD PTR _roth$[ebp], 252381443	; 0f0b0903H
	mov	DWORD PTR _idxg$[ebp], 201851904	; 0c080400H
	mov	DWORD PTR _idxg$[ebp+4], 218694913	; 0d090501H
	mov	DWORD PTR _idxg$[ebp+8], 235537922	; 0e0a0602H
	mov	DWORD PTR _idxg$[ebp+12], 252380931	; 0f0b0703H
	mov	DWORD PTR _idxh$[ebp], 201590784	; 0c040800H
	mov	DWORD PTR _idxh$[ebp+4], 235276802	; 0e060a02H
	mov	DWORD PTR _idxh$[ebp+8], 218433793	; 0d050901H
	mov	DWORD PTR _idxh$[ebp+12], 252119811	; 0f070b03H
	xor	esi, esi
	lea	ebx, DWORD PTR [edx+16]
$LL10@MD4_Transf:

; 71   :     if (i < 16) {

	cmp	esi, 16					; 00000010H
	jae	SHORT $LN7@MD4_Transf

; 72   :       s[0] += F(s[1], s[2], s[3]) + 
; 73   :         c->buf.w[i];

	mov	ecx, DWORD PTR _s$[ebp+8]
	xor	ecx, DWORD PTR _s$[ebp+12]
	and	ecx, DWORD PTR _s$[ebp+4]
	xor	ecx, DWORD PTR _s$[ebp+12]
	add	ecx, DWORD PTR [ebx]
	add	eax, ecx

; 74   :       t = rotf[i%4];

	mov	ecx, esi
	and	ecx, 3
	movzx	ecx, BYTE PTR _rotf$[ebp+ecx]
	jmp	SHORT $LN4@MD4_Transf
$LN7@MD4_Transf:

; 75   :     } else if (i < 32) {
; 76   :       s[0] += G(s[1], s[2], s[3]) + 
; 77   :         c->buf.w[idxg[i%16]] + 0x5a827999L;

	mov	edi, DWORD PTR _s$[ebp+8]
	cmp	esi, 32					; 00000020H
	jae	SHORT $LN5@MD4_Transf
	mov	ecx, edi
	or	ecx, DWORD PTR _s$[ebp+4]
	and	edi, DWORD PTR _s$[ebp+4]
	and	ecx, DWORD PTR _s$[ebp+12]
	or	ecx, edi
	mov	edi, esi
	and	edi, 15					; 0000000fH
	movzx	edi, BYTE PTR _idxg$[ebp+edi]
	add	ecx, DWORD PTR [edx+edi*4+16]
	lea	eax, DWORD PTR [eax+ecx+1518500249]

; 78   :       t = rotg[i%4];

	mov	ecx, esi
	and	ecx, 3
	movzx	ecx, BYTE PTR _rotg$[ebp+ecx]

; 79   :     } else {

	jmp	SHORT $LN4@MD4_Transf
$LN5@MD4_Transf:

; 80   :       s[0] += H(s[1], s[2], s[3]) + 
; 81   :         c->buf.w[idxh[i%16]] + 0x6ed9eba1L;

	xor	edi, DWORD PTR _s$[ebp+4]
	mov	ecx, esi
	xor	edi, DWORD PTR _s$[ebp+12]
	and	ecx, 15					; 0000000fH
	movzx	ecx, BYTE PTR _idxh$[ebp+ecx]
	mov	ecx, DWORD PTR [edx+ecx*4+16]
	add	ecx, edi
	lea	eax, DWORD PTR [eax+ecx+1859775393]

; 82   :       t = roth[i%4];

	mov	ecx, esi
	and	ecx, 3
	movzx	ecx, BYTE PTR _roth$[ebp+ecx]
$LN4@MD4_Transf:

; 83   :     }
; 84   :     t=ROTL32(s[0], t);

	mov	edi, eax

; 85   :     s[0]=s[3];

	mov	eax, DWORD PTR _s$[ebp+12]
	rol	edi, cl

; 86   :     s[3]=s[2];

	mov	ecx, DWORD PTR _s$[ebp+8]
	mov	DWORD PTR _s$[ebp+12], ecx

; 87   :     s[2]=s[1];

	mov	ecx, DWORD PTR _s$[ebp+4]
	inc	esi
	add	ebx, 4
	mov	DWORD PTR _s$[ebp+8], ecx

; 88   :     s[1]=t;

	mov	DWORD PTR _s$[ebp+4], edi
	cmp	esi, 48					; 00000030H
	jb	$LL10@MD4_Transf

; 89   :   }
; 90   : 
; 91   :   for (i=0; i<4; i++) {

	mov	DWORD PTR _s$[ebp], eax
	lea	eax, DWORD PTR _s$[ebp]
	push	4
	sub	eax, edx
	pop	ecx
$LL3@MD4_Transf:

; 92   :     c->s.w[i] += s[i];

	mov	esi, DWORD PTR [eax+edx]
	add	DWORD PTR [edx], esi
	add	edx, 4
	dec	ecx
	jne	SHORT $LL3@MD4_Transf
	pop	edi
	pop	esi
	pop	ebx

; 93   :   }
; 94   : }

	leave
	ret	0
_MD4_Transform ENDP
_TEXT	ENDS
PUBLIC	_MD4_Init
; Function compile flags: /Ogspy
;	COMDAT _MD4_Init
_TEXT	SEGMENT
_c$ = 8							; size = 4
_MD4_Init PROC						; COMDAT

; 102  :   c->len  = 0;

	mov	eax, DWORD PTR _c$[esp-4]
	and	DWORD PTR [eax+80], 0
	and	DWORD PTR [eax+84], 0

; 103  :   c->s.w[0] = 0x67452301;

	mov	DWORD PTR [eax], 1732584193		; 67452301H

; 104  :   c->s.w[1] = 0xefcdab89;

	mov	DWORD PTR [eax+4], -271733879		; efcdab89H

; 105  :   c->s.w[2] = 0x98badcfe;

	mov	DWORD PTR [eax+8], -1732584194		; 98badcfeH

; 106  :   c->s.w[3] = 0x10325476;

	mov	DWORD PTR [eax+12], 271733878		; 10325476H

; 107  : }

	ret	0
_MD4_Init ENDP
_TEXT	ENDS
PUBLIC	_MD4_Update
EXTRN	_memcpy:PROC
; Function compile flags: /Ogspy
;	COMDAT _MD4_Update
_TEXT	SEGMENT
_c$ = 8							; size = 4
_p$ = 12						; size = 4
_in$ = 12						; size = 4
_len$ = 16						; size = 4
_MD4_Update PROC					; COMDAT

; 114  : void MD4_Update (MD4_CTX *c, void *in, uint32_t len) {

	push	ebp
	mov	ebp, esp

; 115  :   uint8_t *p = (uint8_t*)in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 116  :   uint32_t r, idx;
; 117  :   
; 118  :   if (len==0) return;

	mov	eax, DWORD PTR _len$[ebp]
	test	eax, eax
	je	SHORT $LN10@MD4_Update

; 119  :   
; 120  :   // get buffer index
; 121  :   idx = c->len & (MD4_CBLOCK - 1);

	push	esi
	mov	esi, DWORD PTR _c$[ebp]
	push	edi
	mov	edi, DWORD PTR [esi+80]
	and	edi, 63					; 0000003fH

; 122  :   
; 123  :   // update length
; 124  :   c->len += len;

	add	DWORD PTR [esi+80], eax
	adc	DWORD PTR [esi+84], 0

; 125  :   
; 126  :   while (len > 0) {

	test	eax, eax
	je	SHORT $LN13@MD4_Update
	push	ebx
	jmp	SHORT $LN3@MD4_Update
$LL12@MD4_Update:
	mov	eax, DWORD PTR _len$[ebp]
$LN3@MD4_Update:

; 127  :     r = MIN (len, MD4_CBLOCK - idx);

	push	64					; 00000040H
	pop	ebx
	sub	ebx, edi
	cmp	eax, ebx
	jae	SHORT $LN7@MD4_Update
	mov	ebx, eax
$LN7@MD4_Update:

; 128  :     memcpy ((void*)&c->buf.b[idx], p, r);

	push	ebx
	push	DWORD PTR _p$[ebp]
	lea	eax, DWORD PTR [esi+edi+16]
	push	eax
	call	_memcpy

; 129  :     if ((idx + r) < MD4_CBLOCK) break;

	lea	eax, DWORD PTR [ebx+edi]
	add	esp, 12					; 0000000cH
	cmp	eax, 64					; 00000040H
	jb	SHORT $LN15@MD4_Update

; 130  :     
; 131  :     MD4_Transform (c);

	push	esi
	call	_MD4_Transform

; 132  :     len -= r;

	sub	DWORD PTR _len$[ebp], ebx

; 133  :     idx = 0;
; 134  :     p += r;

	add	DWORD PTR _p$[ebp], ebx
	xor	edi, edi
	pop	ecx
	cmp	DWORD PTR _len$[ebp], edi
	ja	SHORT $LL12@MD4_Update
$LN15@MD4_Update:
	pop	ebx
$LN13@MD4_Update:
	pop	edi
	pop	esi
$LN10@MD4_Update:

; 135  :   }
; 136  : }

	pop	ebp
	ret	0
_MD4_Update ENDP
_TEXT	ENDS
PUBLIC	_MD4_Final
EXTRN	_memset:PROC
; Function compile flags: /Ogspy
;	COMDAT _MD4_Final
_TEXT	SEGMENT
_dgst$ = 8						; size = 4
_c$ = 12						; size = 4
_MD4_Final PROC						; COMDAT

; 144  : {

	push	ebx
	push	esi

; 145  :   // see what length we have ere..
; 146  :   uint32_t len=c->len & (MD4_CBLOCK - 1);

	mov	esi, DWORD PTR _c$[esp+4]
	push	edi
	mov	edi, DWORD PTR [esi+80]

; 147  :   // fill with zeros
; 148  :   memset (&c->buf.b[len], 0, MD4_CBLOCK - len);

	push	64					; 00000040H
	pop	eax
	and	edi, 63					; 0000003fH
	sub	eax, edi
	push	eax
	lea	ebx, DWORD PTR [edi+esi+16]
	push	0
	push	ebx
	call	_memset
	add	esp, 12					; 0000000cH

; 149  :   // add the end bit
; 150  :   c->buf.b[len] = 0x80;

	mov	BYTE PTR [ebx], 128			; 00000080H

; 151  :   // if exceeding 56 bytes, transform it
; 152  :   if (len >= 56) {

	cmp	edi, 56					; 00000038H
	jb	SHORT $LN1@MD4_Final

; 153  :     MD4_Transform (c);

	push	esi
	call	_MD4_Transform

; 154  :     // clear
; 155  :     memset (c->buf.b, 0, MD4_CBLOCK);

	push	64					; 00000040H
	lea	eax, DWORD PTR [esi+16]
	push	0
	push	eax
	call	_memset
	add	esp, 16					; 00000010H
$LN1@MD4_Final:

; 156  :   }
; 157  :   // add total bits
; 158  :   c->buf.q[7] = c->len * 8;

	mov	eax, DWORD PTR [esi+80]
	mov	ecx, DWORD PTR [esi+84]
	shld	ecx, eax, 3
	shl	eax, 3

; 159  :   // compress
; 160  :   MD4_Transform(c);

	push	esi
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi+76], ecx
	call	_MD4_Transform

; 161  :   // copy digest to buffer
; 162  :   memcpy (dgst, c->s.b, MD4_DIGEST_LENGTH);

	mov	edi, DWORD PTR _dgst$[esp+12]
	movsd
	movsd
	movsd
	pop	ecx
	movsd
	pop	edi
	pop	esi
	pop	ebx

; 163  : }

	ret	0
_MD4_Final ENDP
_TEXT	ENDS
END
