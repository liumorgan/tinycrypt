; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\hub\sha3\keccak\k400.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_k400_permute
PUBLIC	_rc
; Function compile flags: /Ogspy
; File c:\hub\sha3\keccak\k400.c
;	COMDAT _rc
_TEXT	SEGMENT
_LFSR$ = 8						; size = 4
_rc	PROC						; COMDAT

; 35   : {

	push	ebx
	push	esi
	push	edi

; 36   :   uint16_t c; 
; 37   :   int8_t   t;
; 38   :   uint8_t  i;
; 39   : 
; 40   :   c = 0;
; 41   :   t = *LFSR;

	mov	edi, DWORD PTR _LFSR$[esp+8]
	xor	esi, esi

; 42   :   
; 43   :   for (i=1; i<128; i += i) 

	mov	bh, 1
	mov	bl, BYTE PTR [edi]
$LL4@rc:

; 44   :   {
; 45   :     if (t & 1) {

	test	bl, 1
	je	SHORT $LN6@rc

; 46   :       // if shift value is < 16
; 47   :       if ((i-1) < 16) {

	movzx	eax, bh
	cmp	eax, 17					; 00000011H
	jae	SHORT $LN6@rc

; 48   :         c ^= 1UL << (i - 1);

	movzx	ecx, si
	dec	eax
	btc	ecx, eax
	movzx	esi, cx
$LN6@rc:

; 49   :       }
; 50   :     }
; 51   :     t = (t & 0x80) ? (t << 1) ^ 0x71 : t << 1;

	mov	cl, bl
	add	cl, cl
	mov	al, cl
	movzx	edx, cl
	xor	al, 113					; 00000071H
	test	bl, bl
	movzx	ecx, al
	cmovs	edx, ecx
	add	bh, bh
	mov	bl, dl
	cmp	bh, 128					; 00000080H
	jb	SHORT $LL4@rc

; 52   :   }
; 53   :   *LFSR = (uint8_t)t;

	mov	BYTE PTR [edi], bl

; 54   :   return c;

	mov	ax, si
	pop	edi
	pop	esi
	pop	ebx

; 55   : }

	ret	0
_rc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\sha3\keccak\k400.c
;	COMDAT _k400_permute
_TEXT	SEGMENT
_lfsr$ = -61						; size = 1
_u$1$ = -60						; size = 4
_i$2$ = -56						; size = 4
tv1175 = -52						; size = 4
_m$ = -48						; size = 9
_bc$ = -36						; size = 10
_p$ = -24						; size = 24
_r$1$ = 8						; size = 1
_state$ = 8						; size = 4
_k400_permute PROC					; COMDAT

; 58   : {

	sub	esp, 64					; 00000040H
	push	ebx
	mov	ebx, DWORD PTR _state$[esp+64]
	push	ebp
	push	esi
	push	edi

; 59   :     int     i, j, rnd;
; 60   :     uint16_t t, u, bc[5];
; 61   :     uint8_t  r, lfsr=1;
; 62   :     uint16_t *st=(uint16_t*)state;
; 63   :   
; 64   :     uint8_t p[24] = 

	push	20					; 00000014H
	pop	eax
	mov	DWORD PTR tv1175[esp+80], eax
	mov	BYTE PTR _p$[esp+98], al
	lea	eax, DWORD PTR [ebx+30]
	mov	BYTE PTR _lfsr$[esp+80], 1
	mov	DWORD PTR _p$[esp+80], 285935370	; 110b070aH
	mov	DWORD PTR _p$[esp+84], 268763922	; 10050312H
	mov	DWORD PTR _p$[esp+88], 68687112		; 04181508H
	mov	DWORD PTR _p$[esp+92], 219354895	; 0d13170fH
	mov	WORD PTR _p$[esp+96], 524		; 0000020cH
	mov	DWORD PTR _p$[esp+99], 101258766	; 0609160eH
	mov	BYTE PTR _p$[esp+103], 1

; 65   :     { 10, 7,  11, 17, 18, 3, 5,  16, 8,  21, 24, 4, 
; 66   :       15, 23, 19, 13, 12, 2, 20, 14, 22, 9,  6,  1  };
; 67   :       
; 68   :     uint8_t m[9] = 

	mov	DWORD PTR _m$[esp+80], 50462976		; 03020100H
	mov	DWORD PTR _m$[esp+84], 33619972		; 02010004H
	mov	BYTE PTR _m$[esp+88], 3
$LL4@k400_permu:

; 69   :     { 0, 1, 2, 3, 4, 0, 1, 2, 3};
; 70   :   
; 71   :     for (rnd=0; rnd<20; rnd++) {
; 72   :       // Theta
; 73   :       for (i=0; i<5; i++) {

	push	5
	xor	edx, edx
	mov	ecx, eax
	pop	ebp
$LL7@k400_permu:

; 74   :         t  = st[i   ];
; 75   :         t ^= st[i+ 5];      
; 76   :         t ^= st[i+10];      
; 77   :         t ^= st[i+15];      
; 78   :         t ^= st[i+20];

	mov	ax, WORD PTR [ecx-30]
	xor	ax, WORD PTR [ecx-20]
	xor	ax, WORD PTR [ecx-10]
	xor	ax, WORD PTR [ecx+10]
	xor	ax, WORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+2]

; 79   :         bc[i] = t;

	mov	WORD PTR _bc$[esp+edx*2+80], ax
	inc	edx
	cmp	edx, ebp
	jl	SHORT $LL7@k400_permu

; 80   :       }
; 81   :       for (i=0; i<5; i++) {

	xor	esi, esi
$LL10@k400_permu:

; 82   :         t  = bc[m[(i + 4)]]; 
; 83   :         t ^= ROTL8(bc[m[(i + 1)]], 1);

	movzx	ecx, BYTE PTR _m$[esp+esi+81]
	mov	al, BYTE PTR _bc$[esp+ecx*2+80]
	add	al, al
	movzx	edx, al
	mov	ax, WORD PTR _bc$[esp+ecx*2+80]
	shr	ax, 7
	or	dx, ax
	movzx	eax, BYTE PTR _m$[esp+esi+84]
	xor	dx, WORD PTR _bc$[esp+eax*2+80]

; 84   :         for (j=i; j<25; j+=5) {

	mov	eax, esi
	movzx	ecx, dx
	cmp	esi, 25					; 00000019H
	jge	SHORT $LN8@k400_permu
$LL13@k400_permu:

; 85   :           st[j] ^= t;

	xor	WORD PTR [ebx+eax*2], cx
	add	eax, ebp
	cmp	eax, 25					; 00000019H
	jl	SHORT $LL13@k400_permu
$LN8@k400_permu:

; 80   :       }
; 81   :       for (i=0; i<5; i++) {

	inc	esi
	cmp	esi, ebp
	jl	SHORT $LL10@k400_permu

; 86   :         }
; 87   :       }
; 88   :       // Rho + Pi
; 89   :       u = st[1];

	movzx	eax, WORD PTR [ebx+2]

; 90   :       for (i=0, r=0; i<24; i++) {

	xor	ecx, ecx
	mov	DWORD PTR _u$1$[esp+80], eax
	xor	dl, dl
	mov	DWORD PTR _i$2$[esp+80], ecx
$LL16@k400_permu:

; 91   :         r += i + 1;
; 92   :         u  = ROTL8(u, r & 7);
; 93   :         XCHG(st[p[i]], u);

	movzx	edi, BYTE PTR _p$[esp+ecx+80]
	lea	eax, DWORD PTR [ecx+1]
	add	dl, al
	mov	cl, 8
	mov	eax, DWORD PTR _u$1$[esp+80]
	mov	BYTE PTR _r$1$[esp+76], dl
	and	dl, 7
	movzx	esi, WORD PTR [ebx+edi*2]
	sub	cl, dl
	mov	edx, eax
	shr	dx, cl
	movzx	ecx, BYTE PTR _r$1$[esp+76]
	and	ecx, 7
	shl	al, cl
	mov	ecx, DWORD PTR _i$2$[esp+80]
	movzx	eax, al
	or	dx, ax
	inc	ecx
	mov	WORD PTR [ebx+edi*2], dx
	mov	eax, esi
	mov	dl, BYTE PTR _r$1$[esp+76]
	mov	DWORD PTR _u$1$[esp+80], eax
	mov	DWORD PTR _i$2$[esp+80], ecx
	cmp	ecx, 24					; 00000018H
	jl	SHORT $LL16@k400_permu

; 94   :         bc[0] = u;
; 95   :       }
; 96   :       // Chi
; 97   :       for (i=0; i<25; i+=5) {

	mov	edx, ebx
$LL19@k400_permu:

; 98   :         memcpy(&bc, &st[i], 5*2);

	mov	esi, edx
	lea	edi, DWORD PTR _bc$[esp+80]
	movsd
	movsd
	movsw

; 99   :         for (j=0; j<5; j++) {

	xor	esi, esi
$LL22@k400_permu:

; 100  :           t  = ~bc[m[(j + 1)]];

	movzx	eax, BYTE PTR _m$[esp+esi+81]
	mov	cx, WORD PTR _bc$[esp+eax*2+80]

; 101  :           t &=  bc[m[(j + 2)]];

	movzx	eax, BYTE PTR _m$[esp+esi+82]
	not	cx
	and	cx, WORD PTR _bc$[esp+eax*2+80]

; 102  :           st[j + i] ^= t;

	xor	WORD PTR [edx], cx
	inc	esi
	add	edx, 2
	cmp	esi, 5
	jl	SHORT $LL22@k400_permu

; 94   :         bc[0] = u;
; 95   :       }
; 96   :       // Chi
; 97   :       for (i=0; i<25; i+=5) {

	sub	ebp, 1
	jne	SHORT $LL19@k400_permu

; 103  :         }
; 104  :       }
; 105  :       // Iota
; 106  :       st[0] ^= rc(&lfsr);

	lea	eax, DWORD PTR _lfsr$[esp+80]
	push	eax
	call	_rc
	xor	WORD PTR [ebx], ax
	lea	eax, DWORD PTR [ebx+30]
	sub	DWORD PTR tv1175[esp+84], 1
	pop	ecx
	jne	$LL4@k400_permu
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 107  :     }
; 108  : }

	add	esp, 64					; 00000040H
	ret	0
_k400_permute ENDP
_TEXT	ENDS
END
