; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\hub\sha3\keccak\k800.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_k800_permute
PUBLIC	_rc
; Function compile flags: /Ogspy
; File c:\hub\sha3\keccak\k800.c
;	COMDAT _rc
_TEXT	SEGMENT
_LFSR$ = 8						; size = 4
_rc	PROC						; COMDAT

; 36   : uint32_t rc (uint8_t *LFSR) {

	push	ebx
	push	esi
	push	edi

; 37   :     uint32_t c; 
; 38   :     int8_t   t;
; 39   :     uint8_t  i;
; 40   : 
; 41   :     c = 0;
; 42   :     t = *LFSR;

	mov	edi, DWORD PTR _LFSR$[esp+8]
	xor	esi, esi

; 43   :     
; 44   :     for (i=1; i<128; i += i) 

	mov	bh, 1
	mov	bl, BYTE PTR [edi]
$LL4@rc:

; 45   :     {
; 46   :       if (t & 1) {

	test	bl, 1
	je	SHORT $LN6@rc

; 47   :         // if shift value is < 32
; 48   :         if ((i-1) < 32) {

	movzx	eax, bh
	cmp	eax, 33					; 00000021H
	jae	SHORT $LN6@rc

; 49   :           c ^= 1UL << (i - 1);

	dec	eax
	btc	esi, eax
$LN6@rc:

; 50   :         }
; 51   :       }
; 52   :       t = (t & 0x80) ? (t << 1) ^ 0x71 : t << 1;

	mov	cl, bl
	add	cl, cl
	mov	al, cl
	movzx	edx, cl
	xor	al, 113					; 00000071H
	test	bl, bl
	movzx	ecx, al
	cmovs	edx, ecx
	add	bh, bh
	mov	bl, dl
	cmp	bh, 128					; 00000080H
	jb	SHORT $LL4@rc

; 53   :     }
; 54   :     *LFSR = (uint8_t)t;

	mov	BYTE PTR [edi], bl

; 55   :     return c;

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 56   : }

	ret	0
_rc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\sha3\keccak\k800.c
;	COMDAT _k800_permute
_TEXT	SEGMENT
_lfsr$ = -57						; size = 1
_m5$ = -56						; size = 12
_bc$ = -44						; size = 20
_piln$ = -24						; size = 24
tv1204 = 8						; size = 4
_state$ = 8						; size = 4
_k800_permute PROC					; COMDAT

; 58   : void k800_permute (void *state) {

	sub	esp, 60					; 0000003cH
	push	ebx
	mov	ebx, DWORD PTR _state$[esp+60]
	push	ebp
	push	esi
	push	edi

; 59   :     uint32_t i, j, r, t, u, bc[5];
; 60   :     uint8_t  lfsr=1;

	mov	BYTE PTR _lfsr$[esp+76], 1
	lea	eax, DWORD PTR [ebx+60]

; 61   :     uint32_t *st=(uint32_t*)state;
; 62   :     uint8_t  *p, *m;
; 63   :     int      rnd;
; 64   :     
; 65   :     uint32_t piln[6]=

	mov	DWORD PTR _piln$[esp+76], 285935370	; 110b070aH
	mov	DWORD PTR _piln$[esp+80], 268763922	; 10050312H
	mov	DWORD PTR _piln$[esp+84], 68687112	; 04181508H
	mov	DWORD PTR _piln$[esp+88], 219354895	; 0d13170fH
	mov	DWORD PTR _piln$[esp+92], 236192268	; 0e14020cH
	mov	DWORD PTR _piln$[esp+96], 17172758	; 01060916H

; 66   :     { 0x110b070a, 0x10050312, 0x04181508, 
; 67   :       0x0d13170f, 0x0e14020c, 0x01060916 };
; 68   : 
; 69   :     uint32_t m5[3]=

	mov	DWORD PTR _m5$[esp+76], 50462976	; 03020100H
	mov	DWORD PTR _m5$[esp+80], 33619972	; 02010004H
	mov	DWORD PTR _m5$[esp+84], 1027		; 00000403H
	mov	DWORD PTR tv1204[esp+72], 22		; 00000016H
$LL4@k800_permu:

; 70   :     { 0x03020100, 0x02010004, 0x00000403 };
; 71   :     
; 72   :     p = (uint8_t*)piln;
; 73   :     m = (uint8_t*)m5;
; 74   :     
; 75   :     for (rnd=0; rnd<22; rnd++) {
; 76   :       // Theta
; 77   :       for (i=0; i<5; i++) {     

	xor	edx, edx
	mov	ecx, eax
$LL7@k800_permu:

; 78   :         t  = st[i]; 
; 79   :         t ^= st[i +  5]; 
; 80   :         t ^= st[i + 10]; 
; 81   :         t ^= st[i + 15]; 
; 82   :         t ^= st[i + 20];

	mov	eax, DWORD PTR [ecx-60]
	xor	eax, DWORD PTR [ecx-40]
	xor	eax, DWORD PTR [ecx-20]
	xor	eax, DWORD PTR [ecx+20]
	xor	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+4]

; 83   :         bc[i] = t;

	mov	DWORD PTR _bc$[esp+edx*4+76], eax
	inc	edx
	cmp	edx, 5
	jb	SHORT $LL7@k800_permu

; 84   :       }
; 85   :       for (i=0; i<5; i++) {

	xor	ecx, ecx
$LL10@k800_permu:

; 86   :         t  = bc[m[(i + 4)]]; 
; 87   :         t ^= ROTL32(bc[m[(i + 1)]], 1);

	movzx	eax, BYTE PTR _m5$[esp+ecx+77]
	mov	edx, DWORD PTR _bc$[esp+eax*4+76]
	movzx	eax, BYTE PTR _m5$[esp+ecx+80]
	rol	edx, 1
	xor	edx, DWORD PTR _bc$[esp+eax*4+76]

; 88   :         for (j=i; j<25; j+=5) {

	mov	eax, ecx
	cmp	ecx, 25					; 00000019H
	jae	SHORT $LN8@k800_permu
$LL13@k800_permu:

; 89   :           st[j] ^= t;

	xor	DWORD PTR [ebx+eax*4], edx
	add	eax, 5
	cmp	eax, 25					; 00000019H
	jb	SHORT $LL13@k800_permu
$LN8@k800_permu:

; 84   :       }
; 85   :       for (i=0; i<5; i++) {

	inc	ecx
	cmp	ecx, 5
	jb	SHORT $LL10@k800_permu

; 90   :         }
; 91   :       }
; 92   :       // Rho + Pi
; 93   :       u = st[1];      

	mov	edi, DWORD PTR [ebx+4]

; 94   :       for (i=0, r=0; i<24; i++) {

	xor	ecx, ecx
	xor	esi, esi
$LL16@k800_permu:

; 95   :         r = r + i + 1;    
; 96   :         u  = ROTL32(u, r);
; 97   :         XCHG(st[p[i]], u);

	movzx	edx, BYTE PTR _piln$[esp+esi+76]
	inc	ecx
	add	ecx, esi
	rol	edi, cl
	inc	esi
	mov	eax, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [ebx+edx*4], edi
	mov	edi, eax
	cmp	esi, 24					; 00000018H
	jb	SHORT $LL16@k800_permu

; 98   :         bc[0] = u;
; 99   :       }
; 100  :       // Chi
; 101  :       for (i=0; i<25; i+=5) {

	push	5
	mov	edx, ebx
	pop	ebp
$LL19@k800_permu:

; 102  :         memcpy(&bc, &st[i], 5*4);      

	push	5
	pop	ecx
	mov	esi, edx
	lea	edi, DWORD PTR _bc$[esp+76]
	rep movsd

; 103  :         for (j=0; j<5; j++) {

	xor	esi, esi
$LL22@k800_permu:

; 104  :           t  = ~bc[m[(j + 1)]];

	movzx	eax, BYTE PTR _m5$[esp+esi+77]
	mov	ecx, DWORD PTR _bc$[esp+eax*4+76]

; 105  :           t &=  bc[m[(j + 2)]];        

	movzx	eax, BYTE PTR _m5$[esp+esi+78]
	not	ecx
	and	ecx, DWORD PTR _bc$[esp+eax*4+76]

; 106  :           st[j + i] ^= t;

	xor	DWORD PTR [edx], ecx
	inc	esi
	add	edx, 4
	cmp	esi, 5
	jb	SHORT $LL22@k800_permu

; 98   :         bc[0] = u;
; 99   :       }
; 100  :       // Chi
; 101  :       for (i=0; i<25; i+=5) {

	sub	ebp, 1
	jne	SHORT $LL19@k800_permu

; 107  :         }
; 108  :       }
; 109  :       // Iota
; 110  :       st[0] ^= rc(&lfsr);

	lea	eax, DWORD PTR _lfsr$[esp+76]
	push	eax
	call	_rc
	xor	DWORD PTR [ebx], eax
	lea	eax, DWORD PTR [ebx+60]
	sub	DWORD PTR tv1204[esp+76], 1
	pop	ecx
	jne	$LL4@k800_permu
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 111  :     }
; 112  : }

	add	esp, 60					; 0000003cH
	ret	0
_k800_permute ENDP
_TEXT	ENDS
END
