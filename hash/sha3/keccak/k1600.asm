; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	k1600_permute
PUBLIC	rc
;	COMDAT pdata
pdata	SEGMENT
$pdata$k1600_permute DD imagerel $LN60
	DD	imagerel $LN60+402
	DD	imagerel $unwind$k1600_permute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rc DD	imagerel $LN12
	DD	imagerel $LN12+77
	DD	imagerel $unwind$rc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rc DD	020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$k1600_permute DD 0a1901H
	DD	0166419H
	DD	0153419H
	DD	0f012d219H
	DD	0c00ee010H
	DD	0500b700cH
xdata	ENDS
; Function compile flags: /Ogspy
; File c:\hub\sha3\keccak\k1600.c
;	COMDAT rc
_TEXT	SEGMENT
LFSR$ = 8
rc	PROC						; COMDAT

; 35   : {

$LN12:
	mov	QWORD PTR [rsp+8], rbx

; 36   :   uint64_t c;
; 37   :   uint32_t i, t;
; 38   : 
; 39   :   c = 0;
; 40   :   t = *LFSR;

	movzx	r9d, BYTE PTR [rcx]
	xor	r10d, r10d
	mov	r11, rcx

; 41   :   
; 42   :   for (i=1; i<128; i += i) 

	lea	ebx, QWORD PTR [r10+1]
$LL4@rc:

; 43   :   {
; 44   :     if (t & 1) {

	test	r9b, 1
	je	SHORT $LN5@rc

; 45   :       c ^= (uint64_t)1ULL << (i - 1);

	lea	ecx, DWORD PTR [rbx-1]
	btc	r10, rcx
$LN5@rc:

; 46   :     }
; 47   :     t = (t & 0x80) ? (t << 1) ^ 0x71 : t << 1;

	lea	edx, DWORD PTR [r9+r9]
	mov	r8d, r9d
	mov	ecx, edx
	mov	r9d, edx
	xor	ecx, 113				; 00000071H
	and	r8b, 128				; 00000080H
	cmovne	r9d, ecx
	add	ebx, ebx
	cmp	ebx, 128				; 00000080H
	jb	SHORT $LL4@rc

; 48   :   }
; 49   :   *LFSR = (uint8_t)t;
; 50   :   return c;
; 51   : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rax, r10
	mov	BYTE PTR [r11], r9b
	ret	0
rc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\sha3\keccak\k1600.c
;	COMDAT k1600_permute
_TEXT	SEGMENT
m5$ = 32
piln$ = 48
bc$ = 72
u$ = 160
lfsr$ = 160
state$ = 160
k1600_permute PROC					; COMDAT

; 54   : {

$LN60:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 112				; 00000070H

; 55   :     uint64_t i, j, r, t, u, bc[5];
; 56   :     uint8_t  lfsr=1;

	mov	esi, 24
	mov	BYTE PTR lfsr$[rbp-112], 1
	mov	r14, QWORD PTR u$[rbp-112]
	lea	rdi, QWORD PTR bc$[rbp-112]
	mov	rbx, rcx

; 57   :     uint64_t *st=(uint64_t*)state;
; 58   :     uint8_t  *p, *m;
; 59   :     int      rnd;
; 60   :     
; 61   :     uint32_t piln[6]=

	mov	DWORD PTR piln$[rbp-112], 285935370	; 110b070aH
	mov	DWORD PTR piln$[rbp-108], 268763922	; 10050312H
	sub	rdi, rcx
	lea	r12d, QWORD PTR [rsi-19]
	mov	DWORD PTR piln$[rbp-104], 68687112	; 04181508H
	mov	DWORD PTR piln$[rbp-100], 219354895	; 0d13170fH
	mov	DWORD PTR piln$[rbp-96], 236192268	; 0e14020cH
	mov	DWORD PTR piln$[rbp-92], 17172758	; 01060916H

; 62   :     { 0x110b070a, 0x10050312, 0x04181508, 
; 63   :       0x0d13170f, 0x0e14020c, 0x01060916 };
; 64   : 
; 65   :     // eliminates the need to use modulo operator with 5
; 66   :     uint32_t m5[3]=

	mov	DWORD PTR m5$[rbp-112], 50462976	; 03020100H
	mov	DWORD PTR m5$[rbp-108], 33619972	; 02010004H
	mov	DWORD PTR m5$[rbp-104], 1027		; 00000403H
$LL4@k1600_perm:

; 67   :     { 0x03020100, 0x02010004, 0x00000403 };
; 68   :     
; 69   :     p = (uint8_t*)piln;
; 70   :     m = (uint8_t*)m5;
; 71   :   
; 72   :     for (rnd=0; rnd<24; rnd++) 
; 73   :     {
; 74   :       // Theta
; 75   :       for (i=0; i<5; i++) {     

	lea	rcx, QWORD PTR [rbx+120]
	mov	rdx, r12
$LL7@k1600_perm:

; 76   :         bc[i] = st[i     ] 

	mov	rax, QWORD PTR [rcx-120]
	xor	rax, QWORD PTR [rcx-80]
	xor	rax, QWORD PTR [rcx-40]
	xor	rax, QWORD PTR [rcx+40]
	xor	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdi+rcx-120], rax
	lea	rcx, QWORD PTR [rcx+8]
	sub	rdx, 1
	jne	SHORT $LL7@k1600_perm

; 77   :               ^ st[i +  5] 
; 78   :               ^ st[i + 10] 
; 79   :               ^ st[i + 15] 
; 80   :               ^ st[i + 20];
; 81   :       }
; 82   :       for (i=0; i<5; i++) {

	xor	ecx, ecx
	mov	rdx, rbx
$LL10@k1600_perm:

; 83   :         t  = bc[m5[(i + 4)]];
; 84   :         t ^= ROTL64(bc[m5[(i + 1)]], 1);

	mov	eax, DWORD PTR m5$[rbp+rcx*4-108]
	mov	r9, r12
	mov	r8, QWORD PTR bc$[rbp+rax*8-112]
	mov	eax, DWORD PTR m5$[rbp+rcx*4-96]
	rol	r8, 1
	xor	r8, QWORD PTR bc$[rbp+rax*8-112]
	mov	rax, rdx
$LL13@k1600_perm:

; 85   :         for (j=0; j<25; j+=5) {
; 86   :           st[j + i] ^= t;

	xor	QWORD PTR [rax], r8
	lea	rax, QWORD PTR [rax+40]
	sub	r9, 1
	jne	SHORT $LL13@k1600_perm

; 77   :               ^ st[i +  5] 
; 78   :               ^ st[i + 10] 
; 79   :               ^ st[i + 15] 
; 80   :               ^ st[i + 20];
; 81   :       }
; 82   :       for (i=0; i<5; i++) {

	inc	rcx
	add	rdx, 8
	cmp	rcx, r12
	jb	SHORT $LL10@k1600_perm

; 87   :         }
; 88   :       }
; 89   :       // Rho Pi
; 90   :       t = st[1];
; 91   :       for (i=0, r=0; i<24; i++) {

	xor	r11d, r11d
	xor	r10d, r10d
$LL16@k1600_perm:

; 92   :         r = r + i + 1;
; 93   :         u  = ROTL32(u, r);
; 94   :         XCHG(st[p[i]], u);

	movzx	r9d, BYTE PTR piln$[rbp+r10-112]
	mov	rdx, r14
	inc	r11
	mov	ecx, 32					; 00000020H
	add	r11, r10
	inc	r10
	sub	cl, r11b
	mov	r8, QWORD PTR [rbx+r9*8]
	shr	rdx, cl
	mov	rcx, r11
	shl	r14, cl
	mov	eax, r14d
	mov	r14, r8
	or	rdx, rax
	mov	QWORD PTR [rbx+r9*8], rdx
	cmp	r10, 24
	jb	SHORT $LL16@k1600_perm

; 95   :         bc[0] = u;
; 96   :       }
; 97   :       // Chi
; 98   :       for (j=0; j<25; j+=5) {

	mov	rdx, rbx
	mov	r9, r12
$LL19@k1600_perm:

; 99   :         for (i=0; i<5; i++) {
; 100  :           bc[i] = st[j + i];

	movups	xmm0, XMMWORD PTR [rdx]

; 101  :         }
; 102  :         for (i=0; i<5; i++) {

	xor	r8d, r8d
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR bc$[rbp-112], xmm0
	movsd	xmm0, QWORD PTR [rdx+32]
	movsd	QWORD PTR bc$[rbp-80], xmm0
	movups	XMMWORD PTR bc$[rbp-96], xmm1
$LL25@k1600_perm:

; 103  :           t  = ~bc[m5[(i + 1)]];

	mov	eax, DWORD PTR m5$[rbp+r8*4-108]
	mov	rcx, QWORD PTR bc$[rbp+rax*8-112]

; 104  :           t &= bc[m5[(i + 2)]];

	mov	eax, DWORD PTR m5$[rbp+r8*4-104]
	not	rcx
	inc	r8
	and	rcx, QWORD PTR bc$[rbp+rax*8-112]

; 105  :           st[j + i] ^= t; 

	xor	QWORD PTR [rdx], rcx
	add	rdx, 8
	cmp	r8, r12
	jb	SHORT $LL25@k1600_perm

; 95   :         bc[0] = u;
; 96   :       }
; 97   :       // Chi
; 98   :       for (j=0; j<25; j+=5) {

	sub	r9, 1
	jne	SHORT $LL19@k1600_perm

; 106  :         }
; 107  :       }
; 108  :       // Iota
; 109  :       st[0] ^= rc(&lfsr);

	lea	rcx, QWORD PTR lfsr$[rbp-112]
	call	rc
	xor	QWORD PTR [rbx], rax
	sub	rsi, 1
	jne	$LL4@k1600_perm

; 110  :     }
; 111  : }

	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
k1600_permute ENDP
_TEXT	ENDS
END
