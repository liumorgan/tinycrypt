; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	c:\hub\tinycrypt\permutation\norx\norx1.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_F
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\permutation\norx\norx1.c
;	COMDAT _F
_TEXT	SEGMENT
_idx16$ = -32						; size = 16
_c$ = -16						; size = 4
_d$ = -12						; size = 4
_i$ = -8						; size = 4
_r$ = -4						; size = 4
_s$ = 8							; size = 4
_F	PROC						; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 77   :     int         i;
; 78   :     uint32_t    a, b, c, d, r, t, idx;
; 79   :     
; 80   :     uint16_t idx16[8]=
; 81   :     { 0xC840, 0xD951, 0xEA62, 0xFB73,    // column index
; 82   :       0xFA50, 0xCB61, 0xD872, 0xE943 };  // diagnonal index
; 83   :     
; 84   :     for (i=0; i<8; i++) {

	and	DWORD PTR _i$[ebp], 0
	mov	eax, 51264				; 0000c840H
	mov	WORD PTR _idx16$[ebp], ax
	mov	eax, 55633				; 0000d951H
	mov	WORD PTR _idx16$[ebp+2], ax
	mov	eax, 60002				; 0000ea62H
	mov	WORD PTR _idx16$[ebp+4], ax
	mov	eax, 64371				; 0000fb73H
	mov	WORD PTR _idx16$[ebp+6], ax
	mov	eax, 64080				; 0000fa50H
	mov	WORD PTR _idx16$[ebp+8], ax
	mov	eax, 52065				; 0000cb61H
	mov	WORD PTR _idx16$[ebp+10], ax
	push	ebx
	mov	eax, 55410				; 0000d872H
	push	esi
	mov	WORD PTR _idx16$[ebp+12], ax
	mov	eax, 59715				; 0000e943H
	push	edi
	mov	edi, DWORD PTR _s$[ebp]
	mov	WORD PTR _idx16$[ebp+14], ax
$LL12@F:

; 85   :       idx = idx16[i];

	mov	eax, DWORD PTR _i$[ebp]
	movzx	eax, WORD PTR _idx16$[ebp+eax*2]

; 86   :         
; 87   :       a = (idx         & 0xF);
; 88   :       b = ((idx >>  4) & 0xF);

	mov	edx, eax

; 89   :       c = ((idx >>  8) & 0xF);

	mov	ecx, eax
	mov	esi, eax
	push	15					; 0000000fH
	pop	ebx
	shr	edx, 4
	shr	ecx, 8
	and	ecx, ebx

; 90   :       d = ((idx >> 12) & 0xF);

	shr	eax, 12					; 0000000cH
	and	esi, ebx
	and	edx, ebx
	and	eax, ebx
	mov	DWORD PTR _c$[ebp], ecx
	mov	DWORD PTR _d$[ebp], eax

; 91   :   
; 92   :       r = 0x1F100B08;

	mov	DWORD PTR _r$[ebp], 521145096		; 1f100b08H
$LL3@F:

; 93   :       
; 94   :       /* The quarter-round */
; 95   :       do {
; 96   :         s[a] = H(s[a], s[b]); 

	mov	ebx, DWORD PTR [edi+esi*4]
	mov	ecx, DWORD PTR [edi+edx*4]
	mov	eax, ebx
	and	eax, ecx
	add	eax, eax
	xor	eax, ebx

; 97   :         s[d] = ROTR(s[d] ^ s[a], r & 0xFF);

	mov	ebx, DWORD PTR _d$[ebp]
	xor	eax, ecx
	movzx	ecx, BYTE PTR _r$[ebp]

; 98   :         XCHG(c, a);
; 99   :         XCHG(d, b);
; 100  :         r >>= 8;

	shr	DWORD PTR _r$[ebp], 8
	mov	DWORD PTR [edi+esi*4], eax
	mov	ebx, DWORD PTR [edi+ebx*4]
	xor	ebx, eax
	mov	eax, DWORD PTR _d$[ebp]
	ror	ebx, cl

; 101  :       } while (r != 0);

	cmp	DWORD PTR _r$[ebp], 0
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], esi
	mov	DWORD PTR _d$[ebp], edx
	mov	DWORD PTR [edi+eax*4], ebx
	mov	esi, ecx
	mov	edx, eax
	jne	SHORT $LL3@F

; 77   :     int         i;
; 78   :     uint32_t    a, b, c, d, r, t, idx;
; 79   :     
; 80   :     uint16_t idx16[8]=
; 81   :     { 0xC840, 0xD951, 0xEA62, 0xFB73,    // column index
; 82   :       0xFA50, 0xCB61, 0xD872, 0xE943 };  // diagnonal index
; 83   :     
; 84   :     for (i=0; i<8; i++) {

	inc	DWORD PTR _i$[ebp]
	cmp	DWORD PTR _i$[ebp], 8
	jl	SHORT $LL12@F
	pop	edi
	pop	esi
	pop	ebx

; 102  :     }    
; 103  : }

	leave
	ret	0
_F	ENDP
_TEXT	ENDS
PUBLIC	_norx_permute
; Function compile flags: /Ogspy
;	COMDAT _norx_permute
_TEXT	SEGMENT
_state$ = 8						; size = 4
_norx_permute PROC					; COMDAT

; 107  : {

	push	esi

; 108  :     size_t i;
; 109  :     norx_word_t * S = state->S;
; 110  : 
; 111  :     for (i = 0; i < NORX_L; ++i) {

	push	4
	pop	esi
$LL3@norx_permu:

; 112  :         F(S);

	push	DWORD PTR _state$[esp]
	call	_F
	dec	esi
	pop	ecx
	jne	SHORT $LL3@norx_permu
	pop	esi

; 113  :     }
; 114  : }

	ret	0
_norx_permute ENDP
_TEXT	ENDS
PUBLIC	_norx_absorb_block
; Function compile flags: /Ogspy
;	COMDAT _norx_absorb_block
_TEXT	SEGMENT
_block$ = -92						; size = 192
_state$ = 108						; size = 4
_out$ = 112						; size = 4
_in$ = 116						; size = 4
_inlen$ = 120						; size = 4
_tag$ = 124						; size = 4
_norx_absorb_block PROC					; COMDAT

; 119  : {

	push	ebp
	lea	ebp, DWORD PTR [esp-100]

; 120  :     size_t i;
; 121  :     norx_word_t * S = state->S;
; 122  :     norx_word_t block[BYTES(NORX_R)];
; 123  :     
; 124  :     S[15] ^= tag;

	mov	eax, DWORD PTR _tag$[ebp]
	sub	esp, 192				; 000000c0H
	push	ebx
	mov	ebx, DWORD PTR _state$[ebp]
	xor	DWORD PTR [ebx+60], eax
	push	esi
	push	edi

; 125  :     norx_permute(state);

	push	ebx
	call	_norx_permute

; 126  : 
; 127  :     memset(block, 0, sizeof(block));
; 128  :     memcpy(block, in, inlen);

	mov	edx, DWORD PTR _inlen$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	pop	ecx
	xor	al, al
	lea	edi, DWORD PTR _block$[ebp]
	mov	ecx, 192				; 000000c0H
	rep stosb
	lea	edi, DWORD PTR _block$[ebp]
	mov	ecx, edx
	rep movsb

; 129  :     
; 130  :     if (inlen < BYTES(NORX_R)) {

	cmp	edx, 48					; 00000030H
	jae	SHORT $LN5@norx_absor

; 131  :       ((uint8_t*)block)[inlen] = 0x01;

	mov	BYTE PTR _block$[ebp+edx], 1

; 132  :       ((uint8_t*)block)[BYTES(NORX_R) - 1] |= 0x80;

	or	BYTE PTR _block$[ebp+47], 128		; 00000080H
$LN5@norx_absor:

; 133  :     }
; 134  :     
; 135  :     for (i = 0; i < WORDS(NORX_R); ++i) {

	lea	ecx, DWORD PTR _block$[ebp]
	push	12					; 0000000cH
	mov	eax, ebx
	sub	ecx, ebx
	pop	esi
$LL4@norx_absor:

; 136  :         S[i] ^= block[i];

	mov	edi, DWORD PTR [ecx+eax]
	xor	DWORD PTR [eax], edi
	add	eax, 4
	dec	esi
	jne	SHORT $LL4@norx_absor

; 137  :     }
; 138  :     if (tag==PAYLOAD_TAG) memcpy(out, S, inlen);

	cmp	DWORD PTR _tag$[ebp], 2
	jne	SHORT $LN1@norx_absor
	mov	edi, DWORD PTR _out$[ebp]
	mov	esi, ebx
	mov	ecx, edx
	rep movsb
$LN1@norx_absor:
	pop	edi
	pop	esi
	pop	ebx

; 139  : }

	add	ebp, 100				; 00000064H
	leave
	ret	0
_norx_absorb_block ENDP
_TEXT	ENDS
PUBLIC	_norx_decrypt_block
; Function compile flags: /Ogspy
;	COMDAT _norx_decrypt_block
_TEXT	SEGMENT
_block$ = -88						; size = 192
_state$ = 112						; size = 4
_out$ = 116						; size = 4
_in$ = 120						; size = 4
_len$ = 124						; size = 4
_norx_decrypt_block PROC				; COMDAT

; 143  : {

	push	ebp
	lea	ebp, DWORD PTR [esp-104]
	sub	esp, 192				; 000000c0H
	push	ebx

; 144  :     size_t      i;
; 145  :     norx_word_t *S = state->S;
; 146  :     norx_word_t block[BYTES(NORX_R)];
; 147  :     norx_word_t t;
; 148  :     
; 149  :     S[15] ^= PAYLOAD_TAG;

	mov	ebx, DWORD PTR _state$[ebp]
	xor	DWORD PTR [ebx+60], 2
	push	esi
	push	edi

; 150  :     norx_permute(state);

	push	ebx
	call	_norx_permute

; 151  : 
; 152  :     memcpy (block, S, BYTES(NORX_R));
; 153  :     memcpy (block, in, len);

	mov	eax, DWORD PTR _len$[ebp]
	pop	ecx
	push	48					; 00000030H
	lea	edi, DWORD PTR _block$[ebp]
	mov	esi, ebx
	pop	ecx
	rep movsb
	mov	esi, DWORD PTR _in$[ebp]
	lea	edi, DWORD PTR _block$[ebp]
	mov	ecx, eax
	rep movsb

; 154  :       
; 155  :     if (len < BYTES(NORX_R)) {      

	cmp	eax, 48					; 00000030H
	jge	SHORT $LN4@norx_decry

; 156  :       ((uint8_t*)block)[len] ^= 0x01;

	lea	eax, DWORD PTR _block$[ebp+eax]
	xor	BYTE PTR [eax], 1

; 157  :       ((uint8_t*)block)[BYTES(NORX_R) - 1] ^= 0x80;

	xor	BYTE PTR _block$[ebp+47], 128		; 00000080H
$LN4@norx_decry:

; 158  :     }
; 159  :     
; 160  :     for (i=0; i<WORDS(NORX_R); i++) {

	mov	edi, ebx
	lea	eax, DWORD PTR _block$[ebp]
	xor	esi, esi
	sub	edi, eax
$LL3@norx_decry:
	lea	ecx, DWORD PTR [edi+esi*4]
	lea	eax, DWORD PTR _block$[ebp+esi*4]

; 161  :       t = block[i];  

	mov	edx, DWORD PTR [eax]
	lea	ecx, DWORD PTR _block$[ebp+ecx]

; 162  :       block[i] ^= S[i];

	mov	ebx, DWORD PTR [ecx]
	xor	ebx, edx
	inc	esi
	mov	DWORD PTR [eax], ebx

; 163  :       S[i] = t;

	mov	DWORD PTR [ecx], edx
	cmp	esi, 12					; 0000000cH
	jb	SHORT $LL3@norx_decry

; 164  :     }
; 165  :     memcpy(out, block, len);

	mov	edi, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	lea	esi, DWORD PTR _block$[ebp]
	rep movsb
	pop	edi
	pop	esi
	pop	ebx

; 166  : }

	add	ebp, 104				; 00000068H
	leave
	ret	0
_norx_decrypt_block ENDP
_TEXT	ENDS
PUBLIC	_norx_init
; Function compile flags: /Ogspy
;	COMDAT _norx_init
_TEXT	SEGMENT
_state$ = 8						; size = 4
_key$ = 12						; size = 4
_nonce$ = 16						; size = 4
_norx_init PROC						; COMDAT

; 170  : {

	push	ebx

; 171  :     norx_word_t * S = state->S;
; 172  :     size_t i;
; 173  :     norx_word_t *k=(norx_word_t*)key;
; 174  :     norx_word_t *n=(norx_word_t*)nonce;
; 175  :     
; 176  :     for (i=0; i<16; i++) {

	mov	ebx, DWORD PTR _state$[esp]
	push	esi
	push	edi
	xor	eax, eax
$LL6@norx_init:

; 177  :       S[i] = i;

	mov	DWORD PTR [ebx+eax*4], eax
	inc	eax
	cmp	eax, 16					; 00000010H
	jb	SHORT $LL6@norx_init

; 178  :     }
; 179  : 
; 180  :     F(S); F(S);

	push	ebx
	call	_F
	push	ebx
	call	_F

; 181  : 
; 182  :     memcpy(&S[0], nonce, 16);

	mov	esi, DWORD PTR _nonce$[esp+16]
	push	16					; 00000010H
	pop	ecx
	mov	edi, ebx
	rep movsb

; 183  :     memcpy(&S[4], key,   16);

	mov	esi, DWORD PTR _key$[esp+16]
	push	16					; 00000010H
	pop	ecx
	lea	edi, DWORD PTR [ebx+16]
	rep movsb

; 184  : 
; 185  :     S[12] ^= NORX_W;
; 186  :     S[13] ^= NORX_L;

	xor	DWORD PTR [ebx+52], 4

; 187  :     S[14] ^= NORX_P;

	xor	DWORD PTR [ebx+56], 1

; 188  :     S[15] ^= NORX_T;

	xor	DWORD PTR [ebx+60], 128			; 00000080H
	lea	esi, DWORD PTR [ebx+48]
	xor	DWORD PTR [esi], 32			; 00000020H

; 189  : 
; 190  :     norx_permute(state);

	push	ebx
	call	_norx_permute
	add	esp, 12					; 0000000cH

; 191  : 
; 192  :     for (i=0; i<4; i++) S[i+12] ^= k[i];

	xor	eax, eax
$LL3@norx_init:
	mov	ecx, DWORD PTR _key$[esp+8]
	mov	ecx, DWORD PTR [ecx+eax*4]
	xor	DWORD PTR [esi], ecx
	inc	eax
	add	esi, 4
	cmp	eax, 4
	jb	SHORT $LL3@norx_init

; 193  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
_norx_init ENDP
_TEXT	ENDS
PUBLIC	_norx_absorb_data
; Function compile flags: /Ogspy
;	COMDAT _norx_absorb_data
_TEXT	SEGMENT
_state$ = 8						; size = 4
_in$ = 12						; size = 4
_inlen$ = 16						; size = 4
_tag$ = 20						; size = 4
_norx_absorb_data PROC					; COMDAT

; 197  : {

	push	ebp
	mov	ebp, esp
	push	edi

; 198  :     int len;
; 199  :     
; 200  :     while (inlen) {

	mov	edi, DWORD PTR _inlen$[ebp]
	test	edi, edi
	je	SHORT $LN1@norx_absor@2
	push	esi
$LL2@norx_absor@2:

; 201  :       len = MIN(inlen, BYTES(NORX_R));

	cmp	edi, 48					; 00000030H
	jae	SHORT $LN5@norx_absor@2
	mov	esi, edi
	jmp	SHORT $LN6@norx_absor@2
$LN5@norx_absor@2:
	push	48					; 00000030H
	pop	esi
$LN6@norx_absor@2:

; 202  :       norx_absorb_block(state, 0, (norx_word_t*)in, len, tag);

	push	DWORD PTR _tag$[ebp]
	push	esi
	push	DWORD PTR _in$[ebp]
	push	0
	push	DWORD PTR _state$[ebp]
	call	_norx_absorb_block

; 203  :       
; 204  :       inlen -= len;
; 205  :       in += len;

	add	DWORD PTR _in$[ebp], esi
	add	esp, 20					; 00000014H
	sub	edi, esi
	jne	SHORT $LL2@norx_absor@2
	pop	esi
$LN1@norx_absor@2:
	pop	edi

; 206  :     }
; 207  : }

	pop	ebp
	ret	0
_norx_absorb_data ENDP
_TEXT	ENDS
PUBLIC	_norx_encrypt_data
; Function compile flags: /Ogspy
;	COMDAT _norx_encrypt_data
_TEXT	SEGMENT
_state$ = 8						; size = 4
_out$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_norx_encrypt_data PROC					; COMDAT

; 211  : {

	push	ebp
	mov	ebp, esp
	push	edi

; 212  :     int len;
; 213  :     
; 214  :     while (inlen) {

	mov	edi, DWORD PTR _inlen$[ebp]
	test	edi, edi
	je	SHORT $LN1@norx_encry
	push	esi
$LL2@norx_encry:

; 215  :       len = MIN(inlen, BYTES(NORX_R));

	cmp	edi, 48					; 00000030H
	jae	SHORT $LN5@norx_encry
	mov	esi, edi
	jmp	SHORT $LN6@norx_encry
$LN5@norx_encry:
	push	48					; 00000030H
	pop	esi
$LN6@norx_encry:

; 216  :       norx_absorb_block(state, (norx_word_t*)out, (norx_word_t*)in, len, PAYLOAD_TAG);

	push	2
	push	esi
	push	DWORD PTR _in$[ebp]
	push	DWORD PTR _out$[ebp]
	push	DWORD PTR _state$[ebp]
	call	_norx_absorb_block

; 217  :       
; 218  :       inlen -= len;
; 219  :       in    += len;

	add	DWORD PTR _in$[ebp], esi

; 220  :       out   += len;

	add	DWORD PTR _out$[ebp], esi
	add	esp, 20					; 00000014H
	sub	edi, esi
	jne	SHORT $LL2@norx_encry
	pop	esi
$LN1@norx_encry:
	pop	edi

; 221  :     }
; 222  : }

	pop	ebp
	ret	0
_norx_encrypt_data ENDP
_TEXT	ENDS
PUBLIC	_norx_decrypt_data
; Function compile flags: /Ogspy
;	COMDAT _norx_decrypt_data
_TEXT	SEGMENT
_state$ = 8						; size = 4
_out$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_norx_decrypt_data PROC					; COMDAT

; 226  : {

	push	ebp
	mov	ebp, esp
	push	edi

; 227  :     int len;
; 228  :     
; 229  :     while (inlen) {

	mov	edi, DWORD PTR _inlen$[ebp]
	test	edi, edi
	je	SHORT $LN1@norx_decry@2
	push	esi
$LL2@norx_decry@2:

; 230  :       len = MIN(inlen, BYTES(NORX_R));

	cmp	edi, 48					; 00000030H
	jae	SHORT $LN5@norx_decry@2
	mov	esi, edi
	jmp	SHORT $LN6@norx_decry@2
$LN5@norx_decry@2:
	push	48					; 00000030H
	pop	esi
$LN6@norx_decry@2:

; 231  :       norx_decrypt_block(state, (norx_word_t*)out, (norx_word_t*)in, len);

	push	esi
	push	DWORD PTR _in$[ebp]
	push	DWORD PTR _out$[ebp]
	push	DWORD PTR _state$[ebp]
	call	_norx_decrypt_block

; 232  :       
; 233  :       inlen -= len;
; 234  :       in    += len;

	add	DWORD PTR _in$[ebp], esi

; 235  :       out   += len;

	add	DWORD PTR _out$[ebp], esi
	add	esp, 16					; 00000010H
	sub	edi, esi
	jne	SHORT $LL2@norx_decry@2
	pop	esi
$LN1@norx_decry@2:
	pop	edi

; 236  :     }
; 237  : }

	pop	ebp
	ret	0
_norx_decrypt_data ENDP
_TEXT	ENDS
PUBLIC	_norx_finalise
; Function compile flags: /Ogspy
;	COMDAT _norx_finalise
_TEXT	SEGMENT
_lastblock$ = -64					; size = 64
_state$ = 8						; size = 4
_tag$ = 12						; size = 4
_key$ = 16						; size = 4
_norx_finalise PROC					; COMDAT

; 241  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 242  :     norx_word_t * S = state->S;
; 243  :     uint32_t lastblock[BYTES(NORX_C)];
; 244  :     norx_word_t *k=(norx_word_t*)key;
; 245  :     size_t i;
; 246  :     
; 247  :     S[15] ^= FINAL_TAG;

	mov	edi, DWORD PTR _state$[ebp]
	xor	DWORD PTR [edi+60], 8

; 248  : 
; 249  :     norx_permute(state);

	push	edi
	call	_norx_permute
	mov	ebx, DWORD PTR _key$[ebp]
	lea	esi, DWORD PTR [edi+48]
	pop	ecx

; 250  : 
; 251  :     for (i=0; i<4; i++) S[i+12] ^= k[i];

	xor	ecx, ecx
	mov	eax, esi
$LL9@norx_final:
	mov	edx, DWORD PTR [ebx+ecx*4]
	xor	DWORD PTR [eax], edx
	inc	ecx
	add	eax, 4
	cmp	ecx, 4
	jb	SHORT $LL9@norx_final

; 252  : 
; 253  :     norx_permute(state);

	push	edi
	call	_norx_permute
	pop	ecx

; 254  : 
; 255  :     for (i=0; i<4; i++) S[i+12] ^= k[i];

	xor	ecx, ecx
	mov	eax, esi
$LL6@norx_final:
	mov	edx, DWORD PTR [ebx+ecx*4]
	xor	DWORD PTR [eax], edx
	inc	ecx
	add	eax, 4
	cmp	ecx, 4
	jb	SHORT $LL6@norx_final

; 256  : 
; 257  :     for (i=0; i<4; i++) lastblock[i] = S[i+12];

	lea	edi, DWORD PTR _lastblock$[ebp]
	movsd
	movsd
	movsd
	movsd

; 258  : 
; 259  :     memcpy(tag, lastblock, BYTES(NORX_T));

	mov	edi, DWORD PTR _tag$[ebp]
	push	16					; 00000010H
	pop	ecx
	lea	esi, DWORD PTR _lastblock$[ebp]
	rep movsb
	pop	edi
	pop	esi
	pop	ebx

; 260  : }

	leave
	ret	0
_norx_finalise ENDP
_TEXT	ENDS
PUBLIC	_norx_verify_tag
; Function compile flags: /Ogspy
;	COMDAT _norx_verify_tag
_TEXT	SEGMENT
_tag1$ = 8						; size = 4
_tag2$ = 12						; size = 4
_norx_verify_tag PROC					; COMDAT

; 265  :     size_t i;
; 266  :     unsigned acc = 0;

	mov	eax, DWORD PTR _tag2$[esp-4]

; 267  : 
; 268  :     for (i = 0; i < BYTES(NORX_T); ++i) {

	mov	ecx, DWORD PTR _tag1$[esp-4]
	push	ebx
	push	esi
	push	edi
	push	16					; 00000010H
	xor	edx, edx
	sub	ecx, eax
	pop	esi
$LL3@norx_verif:

; 269  :         acc |= tag1[i] ^ tag2[i];

	movzx	edi, BYTE PTR [ecx+eax]
	movzx	ebx, BYTE PTR [eax]
	xor	edi, ebx
	or	edx, edi
	inc	eax
	dec	esi
	jne	SHORT $LL3@norx_verif

; 270  :     }
; 271  : 
; 272  :     return (((acc - 1) >> 8) & 1) - 1;

	lea	eax, DWORD PTR [edx-1]
	shr	eax, 8
	pop	edi
	and	eax, 1
	pop	esi
	dec	eax
	pop	ebx

; 273  : }

	ret	0
_norx_verify_tag ENDP
_TEXT	ENDS
PUBLIC	_norx_aead_encryptx
; Function compile flags: /Ogspy
;	COMDAT _norx_aead_encryptx
_TEXT	SEGMENT
_state$ = -64						; size = 64
_c$ = 8							; size = 4
_norx_aead_encryptx PROC				; COMDAT

; 277  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi

; 278  :     norx_state_t state;
; 279  : 
; 280  :     norx_init(state, c->k, c->n);

	mov	esi, DWORD PTR _c$[ebp]
	push	DWORD PTR [esi+28]
	lea	eax, DWORD PTR _state$[ebp]
	push	DWORD PTR [esi+16]
	push	eax
	call	_norx_init

; 281  :     norx_absorb_data(state, c->a, c->alen, HEADER_TAG);

	push	1
	push	DWORD PTR [esi+4]
	lea	eax, DWORD PTR _state$[ebp]
	push	DWORD PTR [esi]
	push	eax
	call	_norx_absorb_data

; 282  :     norx_encrypt_data(state, c->c, c->m, c->mlen);

	push	DWORD PTR [esi+24]
	lea	eax, DWORD PTR _state$[ebp]
	push	DWORD PTR [esi+20]
	push	DWORD PTR [esi+8]
	push	eax
	call	_norx_encrypt_data

; 283  :     norx_absorb_data(state, c->z, c->zlen, TRAILER_TAG);

	push	4
	push	DWORD PTR [esi+36]
	lea	eax, DWORD PTR _state$[ebp]
	push	DWORD PTR [esi+32]
	push	eax
	call	_norx_absorb_data

; 284  :     norx_finalise(state, c->c + c->mlen, c->k);

	mov	eax, DWORD PTR [esi+24]
	push	DWORD PTR [esi+16]
	add	eax, DWORD PTR [esi+8]
	push	eax
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_norx_finalise

; 285  :     c->clen = c->mlen + BYTES(NORX_T);

	mov	eax, DWORD PTR [esi+24]
	add	esp, 72					; 00000048H
	add	eax, 16					; 00000010H
	mov	DWORD PTR [esi+12], eax
	pop	esi

; 286  : }

	leave
	ret	0
_norx_aead_encryptx ENDP
_TEXT	ENDS
PUBLIC	_norx_aead_decryptx
; Function compile flags: /Ogspy
;	COMDAT _norx_aead_decryptx
_TEXT	SEGMENT
_state$ = -80						; size = 64
_tag$ = -16						; size = 16
_c$ = 8							; size = 4
_norx_aead_decryptx PROC				; COMDAT

; 289  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi

; 290  :     uint8_t tag[BYTES(NORX_T)];
; 291  :     norx_state_t state;
; 292  :     int result = -1;
; 293  : 
; 294  :     norx_init(state, c->k, c->n);

	mov	esi, DWORD PTR _c$[ebp]
	push	DWORD PTR [esi+28]
	lea	eax, DWORD PTR _state$[ebp]
	push	DWORD PTR [esi+16]
	push	eax
	call	_norx_init

; 295  :     norx_absorb_data(state, c->a, c->alen, HEADER_TAG);

	push	1
	push	DWORD PTR [esi+4]
	lea	eax, DWORD PTR _state$[ebp]
	push	DWORD PTR [esi]
	push	eax
	call	_norx_absorb_data

; 296  :     norx_decrypt_data(state, c->m, c->c, c->clen - BYTES(NORX_T));

	mov	eax, DWORD PTR [esi+12]
	sub	eax, 16					; 00000010H
	push	eax
	push	DWORD PTR [esi+8]
	lea	eax, DWORD PTR _state$[ebp]
	push	DWORD PTR [esi+20]
	push	eax
	call	_norx_decrypt_data

; 297  :     norx_absorb_data(state, c->z, c->zlen, TRAILER_TAG);

	push	4
	push	DWORD PTR [esi+36]
	lea	eax, DWORD PTR _state$[ebp]
	push	DWORD PTR [esi+32]
	push	eax
	call	_norx_absorb_data

; 298  :     norx_finalise(state, tag, c->k);

	push	DWORD PTR [esi+16]
	lea	eax, DWORD PTR _tag$[ebp]
	push	eax
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_norx_finalise

; 299  :     c->mlen = c->clen - BYTES(NORX_T);

	mov	eax, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR [eax-16]
	mov	DWORD PTR [esi+24], ecx
	add	esp, 72					; 00000048H

; 300  : 
; 301  :     result = norx_verify_tag(c->c + c->clen - BYTES(NORX_T), tag);

	lea	ecx, DWORD PTR _tag$[ebp]
	push	ecx

; 302  :     return result;

	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [ecx+eax-16]
	push	eax
	call	_norx_verify_tag
	pop	ecx
	pop	ecx
	pop	esi

; 303  : }

	leave
	ret	0
_norx_aead_decryptx ENDP
_TEXT	ENDS
END
