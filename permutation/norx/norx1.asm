; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	c:\hub\tinycrypt\permutation\norx\norx1.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_F
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\permutation\norx\norx1.c
;	COMDAT _F
_TEXT	SEGMENT
_idx16$ = -32						; size = 16
_c$ = -16						; size = 4
_d$ = -12						; size = 4
_i$ = -8						; size = 4
_r$ = -4						; size = 4
_s$ = 8							; size = 4
_F	PROC						; COMDAT

; 59   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 60   :     int         i;
; 61   :     uint32_t    a, b, c, d, r, t, idx;
; 62   :     
; 63   :     uint16_t idx16[8]=
; 64   :     { 0xC840, 0xD951, 0xEA62, 0xFB73,    // column index
; 65   :       0xFA50, 0xCB61, 0xD872, 0xE943 };  // diagnonal index
; 66   :     
; 67   :     for (i=0; i<8; i++) {

	and	DWORD PTR _i$[ebp], 0
	mov	eax, 51264				; 0000c840H
	mov	WORD PTR _idx16$[ebp], ax
	mov	eax, 55633				; 0000d951H
	mov	WORD PTR _idx16$[ebp+2], ax
	mov	eax, 60002				; 0000ea62H
	mov	WORD PTR _idx16$[ebp+4], ax
	mov	eax, 64371				; 0000fb73H
	mov	WORD PTR _idx16$[ebp+6], ax
	mov	eax, 64080				; 0000fa50H
	mov	WORD PTR _idx16$[ebp+8], ax
	mov	eax, 52065				; 0000cb61H
	mov	WORD PTR _idx16$[ebp+10], ax
	push	ebx
	mov	eax, 55410				; 0000d872H
	push	esi
	mov	WORD PTR _idx16$[ebp+12], ax
	mov	eax, 59715				; 0000e943H
	push	edi
	mov	edi, DWORD PTR _s$[ebp]
	mov	WORD PTR _idx16$[ebp+14], ax
$LL12@F:

; 68   :       idx = idx16[i];

	mov	eax, DWORD PTR _i$[ebp]
	movzx	eax, WORD PTR _idx16$[ebp+eax*2]

; 69   :         
; 70   :       a = (idx         & 0xF);
; 71   :       b = ((idx >>  4) & 0xF);

	mov	edx, eax

; 72   :       c = ((idx >>  8) & 0xF);

	mov	ecx, eax
	mov	esi, eax
	push	15					; 0000000fH
	pop	ebx
	shr	edx, 4
	shr	ecx, 8
	and	ecx, ebx

; 73   :       d = ((idx >> 12) & 0xF);

	shr	eax, 12					; 0000000cH
	and	esi, ebx
	and	edx, ebx
	and	eax, ebx
	mov	DWORD PTR _c$[ebp], ecx
	mov	DWORD PTR _d$[ebp], eax

; 74   :   
; 75   :       r = 0x1F100B08;

	mov	DWORD PTR _r$[ebp], 521145096		; 1f100b08H
$LL3@F:

; 76   :       
; 77   :       /* The quarter-round */
; 78   :       do {
; 79   :         s[a] = H(s[a], s[b]); 

	mov	ebx, DWORD PTR [edi+esi*4]
	mov	ecx, DWORD PTR [edi+edx*4]
	mov	eax, ebx
	and	eax, ecx
	add	eax, eax
	xor	eax, ebx

; 80   :         s[d] = ROTR(s[d] ^ s[a], r & 0xFF);

	mov	ebx, DWORD PTR _d$[ebp]
	xor	eax, ecx
	movzx	ecx, BYTE PTR _r$[ebp]

; 81   :         XCHG(c, a);
; 82   :         XCHG(d, b);
; 83   :         r >>= 8;

	shr	DWORD PTR _r$[ebp], 8
	mov	DWORD PTR [edi+esi*4], eax
	mov	ebx, DWORD PTR [edi+ebx*4]
	xor	ebx, eax
	mov	eax, DWORD PTR _d$[ebp]
	ror	ebx, cl

; 84   :       } while (r != 0);

	cmp	DWORD PTR _r$[ebp], 0
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], esi
	mov	DWORD PTR _d$[ebp], edx
	mov	DWORD PTR [edi+eax*4], ebx
	mov	esi, ecx
	mov	edx, eax
	jne	SHORT $LL3@F

; 60   :     int         i;
; 61   :     uint32_t    a, b, c, d, r, t, idx;
; 62   :     
; 63   :     uint16_t idx16[8]=
; 64   :     { 0xC840, 0xD951, 0xEA62, 0xFB73,    // column index
; 65   :       0xFA50, 0xCB61, 0xD872, 0xE943 };  // diagnonal index
; 66   :     
; 67   :     for (i=0; i<8; i++) {

	inc	DWORD PTR _i$[ebp]
	cmp	DWORD PTR _i$[ebp], 8
	jl	SHORT $LL12@F
	pop	edi
	pop	esi
	pop	ebx

; 85   :     }    
; 86   : }

	leave
	ret	0
_F	ENDP
_TEXT	ENDS
PUBLIC	_norx_permute
; Function compile flags: /Ogspy
;	COMDAT _norx_permute
_TEXT	SEGMENT
_state$ = 8						; size = 4
_norx_permute PROC					; COMDAT

; 90   : {

	push	esi

; 91   :     size_t i;
; 92   :     norx_word_t * S = state->S;
; 93   : 
; 94   :     for (i = 0; i < NORX_L; ++i) {

	push	4
	pop	esi
$LL3@norx_permu:

; 95   :         F(S);

	push	DWORD PTR _state$[esp]
	call	_F
	dec	esi
	pop	ecx
	jne	SHORT $LL3@norx_permu
	pop	esi

; 96   :     }
; 97   : }

	ret	0
_norx_permute ENDP
_TEXT	ENDS
PUBLIC	_norx_pad
; Function compile flags: /Ogspy
;	COMDAT _norx_pad
_TEXT	SEGMENT
_out$ = 8						; size = 4
_in$ = 12						; size = 4
_inlen$ = 16						; size = 4
_norx_pad PROC						; COMDAT

; 101  :     memset(out, 0, BYTES(NORX_R));

	mov	edx, DWORD PTR _out$[esp-4]
	push	esi

; 102  :     memcpy(out, in, inlen);

	mov	esi, DWORD PTR _in$[esp]
	push	edi
	push	48					; 00000030H
	pop	ecx
	xor	al, al
	mov	edi, edx
	rep stosb
	mov	eax, DWORD PTR _inlen$[esp+4]
	mov	edi, edx
	mov	ecx, eax
	rep movsb
	pop	edi

; 103  :     
; 104  :     out[inlen] = 0x01;

	mov	BYTE PTR [edx+eax], 1

; 105  :     out[BYTES(NORX_R) - 1] |= 0x80;

	or	BYTE PTR [edx+47], 128			; 00000080H
	pop	esi

; 106  : }

	ret	0
_norx_pad ENDP
_TEXT	ENDS
PUBLIC	_norx_absorb_block
; Function compile flags: /Ogspy
;	COMDAT _norx_absorb_block
_TEXT	SEGMENT
_lastblock$ = -48					; size = 48
_state$ = 8						; size = 4
_in$ = 12						; size = 4
_inlen$ = 16						; size = 4
_tag$ = 20						; size = 4
_norx_absorb_block PROC					; COMDAT

; 110  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 111  :     size_t i;
; 112  :     norx_word_t * S = state->S;
; 113  :     uint8_t lastblock[BYTES(NORX_R)];
; 114  :     uint32_t *p=(uint32_t*)in;
; 115  :     
; 116  :     if (inlen < BYTES(NORX_R)) {

	cmp	DWORD PTR _inlen$[ebp], 48		; 00000030H
	push	esi
	push	edi
	mov	edi, DWORD PTR _in$[ebp]
	jae	SHORT $LN4@norx_absor

; 117  :       norx_pad(lastblock, (uint8_t*)in, inlen);

	push	DWORD PTR _inlen$[ebp]
	lea	eax, DWORD PTR _lastblock$[ebp]
	push	edi
	push	eax
	call	_norx_pad
	add	esp, 12					; 0000000cH

; 118  :       p=(uint32_t*)lastblock;

	lea	edi, DWORD PTR _lastblock$[ebp]
$LN4@norx_absor:

; 119  :     }
; 120  :     S[15] ^= tag;

	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _tag$[ebp]
	xor	DWORD PTR [esi+60], eax

; 121  :     norx_permute(state);

	push	esi
	call	_norx_permute
	pop	ecx

; 122  : 
; 123  :     for (i = 0; i < WORDS(NORX_R); ++i) {

	mov	ecx, edi
	push	12					; 0000000cH
	mov	eax, esi
	sub	ecx, esi
	pop	edx
$LL3@norx_absor:

; 124  :         S[i] ^= p[i];

	mov	esi, DWORD PTR [ecx+eax]
	xor	DWORD PTR [eax], esi
	add	eax, 4
	dec	edx
	jne	SHORT $LL3@norx_absor
	pop	edi
	pop	esi

; 125  :     }
; 126  : }

	leave
	ret	0
_norx_absorb_block ENDP
_TEXT	ENDS
PUBLIC	_norx_encrypt_block
; Function compile flags: /Ogspy
;	COMDAT _norx_encrypt_block
_TEXT	SEGMENT
_block$ = -48						; size = 48
_state$ = 8						; size = 4
_out$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_norx_encrypt_block PROC				; COMDAT

; 130  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 131  :     size_t i;
; 132  :     norx_word_t * S = state->S;
; 133  :     uint8_t block[BYTES(NORX_R)];
; 134  :     uint32_t *p=(uint32_t*)in;
; 135  :     
; 136  :     if (inlen < BYTES(NORX_R)) {

	cmp	DWORD PTR _inlen$[ebp], 48		; 00000030H
	push	esi
	push	edi
	mov	edi, DWORD PTR _in$[ebp]
	jge	SHORT $LN4@norx_encry

; 137  :       norx_pad(block, (uint8_t*)in, inlen);

	push	DWORD PTR _inlen$[ebp]
	lea	eax, DWORD PTR _block$[ebp]
	push	edi
	push	eax
	call	_norx_pad
	add	esp, 12					; 0000000cH

; 138  :       p=(uint32_t*)block;

	lea	edi, DWORD PTR _block$[ebp]
$LN4@norx_encry:

; 139  :     }
; 140  :     
; 141  :     S[15] ^= PAYLOAD_TAG;

	mov	esi, DWORD PTR _state$[ebp]
	xor	DWORD PTR [esi+60], 2

; 142  :     norx_permute(state);

	push	esi
	call	_norx_permute
	pop	ecx

; 143  : 
; 144  :     for (i=0; i<WORDS(NORX_R); i++) {

	mov	ecx, edi
	push	12					; 0000000cH
	mov	eax, esi
	sub	ecx, esi
	pop	edx
$LL3@norx_encry:

; 145  :       S[i] ^= p[i];

	mov	edi, DWORD PTR [ecx+eax]
	xor	DWORD PTR [eax], edi
	add	eax, 4
	dec	edx
	jne	SHORT $LL3@norx_encry

; 146  :     }
; 147  :     memcpy(out, S, inlen);

	mov	edi, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _inlen$[ebp]
	rep movsb
	pop	edi
	pop	esi

; 148  :     
; 149  : }

	leave
	ret	0
_norx_encrypt_block ENDP
_TEXT	ENDS
PUBLIC	_norx_decrypt_block
; Function compile flags: /Ogspy
;	COMDAT _norx_decrypt_block
_TEXT	SEGMENT
_block$ = -88						; size = 192
_state$ = 112						; size = 4
_out$ = 116						; size = 4
_in$ = 120						; size = 4
_len$ = 124						; size = 4
_norx_decrypt_block PROC				; COMDAT

; 153  : {

	push	ebp
	lea	ebp, DWORD PTR [esp-104]
	sub	esp, 192				; 000000c0H
	push	ebx

; 154  :     size_t      i;
; 155  :     norx_word_t *S = state->S;
; 156  :     norx_word_t block[BYTES(NORX_R)];
; 157  :     
; 158  :     S[15] ^= PAYLOAD_TAG;

	mov	ebx, DWORD PTR _state$[ebp]
	xor	DWORD PTR [ebx+60], 2
	push	esi
	push	edi

; 159  :     norx_permute(state);

	push	ebx
	call	_norx_permute

; 160  : 
; 161  :     memcpy (block, S, BYTES(NORX_R));
; 162  :     memcpy (block, in, len);

	mov	eax, DWORD PTR _len$[ebp]
	pop	ecx
	push	48					; 00000030H
	lea	edi, DWORD PTR _block$[ebp]
	mov	esi, ebx
	pop	ecx
	rep movsb
	mov	esi, DWORD PTR _in$[ebp]
	lea	edi, DWORD PTR _block$[ebp]
	mov	ecx, eax
	rep movsb

; 163  :       
; 164  :     if (len < BYTES(NORX_R)) {      

	cmp	eax, 48					; 00000030H
	jge	SHORT $LN4@norx_decry

; 165  :       ((uint8_t*)block)[len] ^= 0x01;

	lea	eax, DWORD PTR _block$[ebp+eax]
	xor	BYTE PTR [eax], 1

; 166  :       ((uint8_t*)block)[BYTES(NORX_R) - 1] ^= 0x80;

	xor	BYTE PTR _block$[ebp+47], 128		; 00000080H
$LN4@norx_decry:

; 167  :     }
; 168  :     
; 169  :     for (i = 0; i < WORDS(NORX_R); ++i) {

	lea	edx, DWORD PTR _block$[ebp]
	push	12					; 0000000cH
	mov	eax, ebx
	sub	edx, ebx
	pop	esi
$LL3@norx_decry:

; 170  :         const norx_word_t c = block[i];

	mov	ecx, DWORD PTR [edx+eax]

; 171  :         block[i] = S[i] ^ c;

	mov	edi, DWORD PTR [eax]
	xor	edi, ecx
	mov	DWORD PTR [edx+eax], edi

; 172  :         S[i] = c;

	mov	DWORD PTR [eax], ecx
	add	eax, 4
	dec	esi
	jne	SHORT $LL3@norx_decry

; 173  :     }
; 174  :     memcpy(out, block, len);

	mov	edi, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	lea	esi, DWORD PTR _block$[ebp]
	rep movsb
	pop	edi
	pop	esi
	pop	ebx

; 175  : }

	add	ebp, 104				; 00000068H
	leave
	ret	0
_norx_decrypt_block ENDP
_TEXT	ENDS
PUBLIC	_norx_init
; Function compile flags: /Ogspy
;	COMDAT _norx_init
_TEXT	SEGMENT
_state$ = 8						; size = 4
_key$ = 12						; size = 4
_nonce$ = 16						; size = 4
_norx_init PROC						; COMDAT

; 179  : {

	push	ebx

; 180  :     norx_word_t * S = state->S;
; 181  :     size_t i;
; 182  :     norx_word_t *k=(norx_word_t*)key;
; 183  :     norx_word_t *n=(norx_word_t*)nonce;
; 184  :     
; 185  :     for (i=0; i<16; i++) {

	mov	ebx, DWORD PTR _state$[esp]
	push	esi
	push	edi
	xor	eax, eax
$LL6@norx_init:

; 186  :       S[i] = i;

	mov	DWORD PTR [ebx+eax*4], eax
	inc	eax
	cmp	eax, 16					; 00000010H
	jb	SHORT $LL6@norx_init

; 187  :     }
; 188  : 
; 189  :     F(S); F(S);

	push	ebx
	call	_F
	push	ebx
	call	_F

; 190  : 
; 191  :     memcpy(&S[0], nonce, 16);

	mov	esi, DWORD PTR _nonce$[esp+16]
	push	16					; 00000010H
	pop	ecx
	mov	edi, ebx
	rep movsb

; 192  :     memcpy(&S[4], key,   16);

	mov	esi, DWORD PTR _key$[esp+16]
	push	16					; 00000010H
	pop	ecx
	lea	edi, DWORD PTR [ebx+16]
	rep movsb

; 193  : 
; 194  :     S[12] ^= NORX_W;
; 195  :     S[13] ^= NORX_L;

	xor	DWORD PTR [ebx+52], 4

; 196  :     S[14] ^= NORX_P;

	xor	DWORD PTR [ebx+56], 1

; 197  :     S[15] ^= NORX_T;

	xor	DWORD PTR [ebx+60], 128			; 00000080H
	lea	esi, DWORD PTR [ebx+48]
	xor	DWORD PTR [esi], 32			; 00000020H

; 198  : 
; 199  :     norx_permute(state);

	push	ebx
	call	_norx_permute
	add	esp, 12					; 0000000cH

; 200  : 
; 201  :     for (i=0; i<4; i++) S[i+12] ^= k[i];

	xor	eax, eax
$LL3@norx_init:
	mov	ecx, DWORD PTR _key$[esp+8]
	mov	ecx, DWORD PTR [ecx+eax*4]
	xor	DWORD PTR [esi], ecx
	inc	eax
	add	esi, 4
	cmp	eax, 4
	jb	SHORT $LL3@norx_init

; 202  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
_norx_init ENDP
_TEXT	ENDS
PUBLIC	_norx_absorb_data
; Function compile flags: /Ogspy
;	COMDAT _norx_absorb_data
_TEXT	SEGMENT
_state$ = 8						; size = 4
_in$ = 12						; size = 4
_inlen$ = 16						; size = 4
_tag$ = 20						; size = 4
_norx_absorb_data PROC					; COMDAT

; 206  : {

	push	ebp
	mov	ebp, esp
	push	edi

; 207  :     int len;
; 208  :     
; 209  :     while (inlen) {

	mov	edi, DWORD PTR _inlen$[ebp]
	test	edi, edi
	je	SHORT $LN1@norx_absor@2
	push	esi
$LL2@norx_absor@2:

; 210  :       len = MIN(inlen, BYTES(NORX_R));

	cmp	edi, 48					; 00000030H
	jae	SHORT $LN5@norx_absor@2
	mov	esi, edi
	jmp	SHORT $LN6@norx_absor@2
$LN5@norx_absor@2:
	push	48					; 00000030H
	pop	esi
$LN6@norx_absor@2:

; 211  :       norx_absorb_block(state, (norx_word_t*)in, len, tag);

	push	DWORD PTR _tag$[ebp]
	push	esi
	push	DWORD PTR _in$[ebp]
	push	DWORD PTR _state$[ebp]
	call	_norx_absorb_block

; 212  :       
; 213  :       inlen -= len;
; 214  :       in += len;

	add	DWORD PTR _in$[ebp], esi
	add	esp, 16					; 00000010H
	sub	edi, esi
	jne	SHORT $LL2@norx_absor@2
	pop	esi
$LN1@norx_absor@2:
	pop	edi

; 215  :     }
; 216  : }

	pop	ebp
	ret	0
_norx_absorb_data ENDP
_TEXT	ENDS
PUBLIC	_norx_encrypt_data
; Function compile flags: /Ogspy
;	COMDAT _norx_encrypt_data
_TEXT	SEGMENT
_state$ = 8						; size = 4
_out$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_norx_encrypt_data PROC					; COMDAT

; 220  : {

	push	ebp
	mov	ebp, esp
	push	edi

; 221  :     int len;
; 222  :     
; 223  :     while (inlen) {

	mov	edi, DWORD PTR _inlen$[ebp]
	test	edi, edi
	je	SHORT $LN1@norx_encry@2
	push	esi
$LL2@norx_encry@2:

; 224  :       len = MIN(inlen, BYTES(NORX_R));

	cmp	edi, 48					; 00000030H
	jae	SHORT $LN5@norx_encry@2
	mov	esi, edi
	jmp	SHORT $LN6@norx_encry@2
$LN5@norx_encry@2:
	push	48					; 00000030H
	pop	esi
$LN6@norx_encry@2:

; 225  :       norx_encrypt_block(state, (norx_word_t*)out, (norx_word_t*)in, len);

	push	esi
	push	DWORD PTR _in$[ebp]
	push	DWORD PTR _out$[ebp]
	push	DWORD PTR _state$[ebp]
	call	_norx_encrypt_block

; 226  :       
; 227  :       inlen -= len;
; 228  :       in    += len;

	add	DWORD PTR _in$[ebp], esi

; 229  :       out   += len;

	add	DWORD PTR _out$[ebp], esi
	add	esp, 16					; 00000010H
	sub	edi, esi
	jne	SHORT $LL2@norx_encry@2
	pop	esi
$LN1@norx_encry@2:
	pop	edi

; 230  :     }
; 231  : }

	pop	ebp
	ret	0
_norx_encrypt_data ENDP
_TEXT	ENDS
PUBLIC	_norx_decrypt_data
; Function compile flags: /Ogspy
;	COMDAT _norx_decrypt_data
_TEXT	SEGMENT
_state$ = 8						; size = 4
_out$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_norx_decrypt_data PROC					; COMDAT

; 235  : {

	push	ebp
	mov	ebp, esp
	push	edi

; 236  :     int len;
; 237  :     
; 238  :     while (inlen) {

	mov	edi, DWORD PTR _inlen$[ebp]
	test	edi, edi
	je	SHORT $LN1@norx_decry@2
	push	esi
$LL2@norx_decry@2:

; 239  :       len = MIN(inlen, BYTES(NORX_R));

	cmp	edi, 48					; 00000030H
	jae	SHORT $LN5@norx_decry@2
	mov	esi, edi
	jmp	SHORT $LN6@norx_decry@2
$LN5@norx_decry@2:
	push	48					; 00000030H
	pop	esi
$LN6@norx_decry@2:

; 240  :       norx_decrypt_block(state, (norx_word_t*)out, (norx_word_t*)in, len);

	push	esi
	push	DWORD PTR _in$[ebp]
	push	DWORD PTR _out$[ebp]
	push	DWORD PTR _state$[ebp]
	call	_norx_decrypt_block

; 241  :       
; 242  :       inlen -= len;
; 243  :       in    += len;

	add	DWORD PTR _in$[ebp], esi

; 244  :       out   += len;

	add	DWORD PTR _out$[ebp], esi
	add	esp, 16					; 00000010H
	sub	edi, esi
	jne	SHORT $LL2@norx_decry@2
	pop	esi
$LN1@norx_decry@2:
	pop	edi

; 245  :     }
; 246  : }

	pop	ebp
	ret	0
_norx_decrypt_data ENDP
_TEXT	ENDS
PUBLIC	_norx_finalise
; Function compile flags: /Ogspy
;	COMDAT _norx_finalise
_TEXT	SEGMENT
_lastblock$ = -64					; size = 64
_state$ = 8						; size = 4
_tag$ = 12						; size = 4
_key$ = 16						; size = 4
_norx_finalise PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 251  :     norx_word_t * S = state->S;
; 252  :     uint32_t lastblock[BYTES(NORX_C)];
; 253  :     norx_word_t *k=(norx_word_t*)key;
; 254  :     size_t i;
; 255  :     
; 256  :     S[15] ^= FINAL_TAG;

	mov	edi, DWORD PTR _state$[ebp]
	xor	DWORD PTR [edi+60], 8

; 257  : 
; 258  :     norx_permute(state);

	push	edi
	call	_norx_permute
	mov	ebx, DWORD PTR _key$[ebp]
	lea	esi, DWORD PTR [edi+48]
	pop	ecx

; 259  : 
; 260  :     for (i=0; i<4; i++) S[i+12] ^= k[i];

	xor	ecx, ecx
	mov	eax, esi
$LL9@norx_final:
	mov	edx, DWORD PTR [ebx+ecx*4]
	xor	DWORD PTR [eax], edx
	inc	ecx
	add	eax, 4
	cmp	ecx, 4
	jb	SHORT $LL9@norx_final

; 261  : 
; 262  :     norx_permute(state);

	push	edi
	call	_norx_permute
	pop	ecx

; 263  : 
; 264  :     for (i=0; i<4; i++) S[i+12] ^= k[i];

	xor	ecx, ecx
	mov	eax, esi
$LL6@norx_final:
	mov	edx, DWORD PTR [ebx+ecx*4]
	xor	DWORD PTR [eax], edx
	inc	ecx
	add	eax, 4
	cmp	ecx, 4
	jb	SHORT $LL6@norx_final

; 265  : 
; 266  :     for (i=0; i<4; i++) lastblock[i] = S[i+12];

	lea	edi, DWORD PTR _lastblock$[ebp]
	movsd
	movsd
	movsd
	movsd

; 267  : 
; 268  :     memcpy(tag, lastblock, BYTES(NORX_T));

	mov	edi, DWORD PTR _tag$[ebp]
	push	16					; 00000010H
	pop	ecx
	lea	esi, DWORD PTR _lastblock$[ebp]
	rep movsb
	pop	edi
	pop	esi
	pop	ebx

; 269  : }

	leave
	ret	0
_norx_finalise ENDP
_TEXT	ENDS
PUBLIC	_norx_verify_tag
; Function compile flags: /Ogspy
;	COMDAT _norx_verify_tag
_TEXT	SEGMENT
_tag1$ = 8						; size = 4
_tag2$ = 12						; size = 4
_norx_verify_tag PROC					; COMDAT

; 274  :     size_t i;
; 275  :     unsigned acc = 0;

	mov	eax, DWORD PTR _tag2$[esp-4]

; 276  : 
; 277  :     for (i = 0; i < BYTES(NORX_T); ++i) {

	mov	ecx, DWORD PTR _tag1$[esp-4]
	push	ebx
	push	esi
	push	edi
	push	16					; 00000010H
	xor	edx, edx
	sub	ecx, eax
	pop	esi
$LL3@norx_verif:

; 278  :         acc |= tag1[i] ^ tag2[i];

	movzx	edi, BYTE PTR [ecx+eax]
	movzx	ebx, BYTE PTR [eax]
	xor	edi, ebx
	or	edx, edi
	inc	eax
	dec	esi
	jne	SHORT $LL3@norx_verif

; 279  :     }
; 280  : 
; 281  :     return (((acc - 1) >> 8) & 1) - 1;

	lea	eax, DWORD PTR [edx-1]
	shr	eax, 8
	pop	edi
	and	eax, 1
	pop	esi
	dec	eax
	pop	ebx

; 282  : }

	ret	0
_norx_verify_tag ENDP
_TEXT	ENDS
PUBLIC	_norx_aead_encrypt
; Function compile flags: /Ogspy
;	COMDAT _norx_aead_encrypt
_TEXT	SEGMENT
_state$ = -80						; size = 64
_k$ = -16						; size = 16
_c$ = 8							; size = 4
_clen$ = 12						; size = 4
_a$ = 16						; size = 4
_alen$ = 20						; size = 4
_m$ = 24						; size = 4
_mlen$ = 28						; size = 4
_z$ = 32						; size = 4
_zlen$ = 36						; size = 4
_nonce$ = 40						; size = 4
_key$ = 44						; size = 4
_norx_aead_encrypt PROC					; COMDAT

; 293  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi

; 294  :     unsigned char k[BYTES(NORX_K)];
; 295  :     norx_state_t state;
; 296  : 
; 297  :     memcpy(k, key, sizeof(k));

	mov	esi, DWORD PTR _key$[ebp]
	push	edi
	push	16					; 00000010H
	pop	ecx

; 298  :     norx_init(state, k, nonce);

	push	DWORD PTR _nonce$[ebp]
	lea	eax, DWORD PTR _k$[ebp]
	push	eax
	lea	eax, DWORD PTR _state$[ebp]
	lea	edi, DWORD PTR _k$[ebp]
	push	eax
	rep movsb
	call	_norx_init

; 299  :     norx_absorb_data(state, a, alen, HEADER_TAG);

	push	1
	push	DWORD PTR _alen$[ebp]
	lea	eax, DWORD PTR _state$[ebp]
	push	DWORD PTR _a$[ebp]
	push	eax
	call	_norx_absorb_data

; 300  :     norx_encrypt_data(state, c, m, mlen);

	mov	esi, DWORD PTR _mlen$[ebp]
	mov	edi, DWORD PTR _c$[ebp]
	push	esi
	push	DWORD PTR _m$[ebp]
	lea	eax, DWORD PTR _state$[ebp]
	push	edi
	push	eax
	call	_norx_encrypt_data

; 301  :     norx_absorb_data(state, z, zlen, TRAILER_TAG);

	push	4
	push	DWORD PTR _zlen$[ebp]
	lea	eax, DWORD PTR _state$[ebp]
	push	DWORD PTR _z$[ebp]
	push	eax
	call	_norx_absorb_data

; 302  :     norx_finalise(state, c + mlen, k);

	lea	eax, DWORD PTR _k$[ebp]
	push	eax
	add	edi, esi
	lea	eax, DWORD PTR _state$[ebp]
	push	edi
	push	eax
	call	_norx_finalise

; 303  :     *clen = mlen + BYTES(NORX_T);

	mov	eax, DWORD PTR _clen$[ebp]
	add	esp, 72					; 00000048H
	add	esi, 16					; 00000010H
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 304  : }

	leave
	ret	0
_norx_aead_encrypt ENDP
_TEXT	ENDS
PUBLIC	_norx_aead_decrypt
; Function compile flags: /Ogspy
;	COMDAT _norx_aead_decrypt
_TEXT	SEGMENT
_state$ = -96						; size = 64
_tag$ = -32						; size = 16
_k$ = -16						; size = 16
_m$ = 8							; size = 4
_mlen$ = 12						; size = 4
_a$ = 16						; size = 4
_alen$ = 20						; size = 4
_c$ = 24						; size = 4
_clen$ = 28						; size = 4
_z$ = 32						; size = 4
_zlen$ = 36						; size = 4
_nonce$ = 40						; size = 4
_key$ = 44						; size = 4
_norx_aead_decrypt PROC					; COMDAT

; 314  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx

; 315  :     unsigned char k[BYTES(NORX_K)];
; 316  :     unsigned char tag[BYTES(NORX_T)];
; 317  :     norx_state_t state;
; 318  :     int result = -1;
; 319  : 
; 320  :     if (clen < BYTES(NORX_T)) {

	mov	ebx, DWORD PTR _clen$[ebp]
	push	16					; 00000010H
	pop	ecx
	cmp	ebx, ecx
	jae	SHORT $LN1@norx_aead_

; 321  :         return -1;

	or	eax, -1
	jmp	SHORT $LN2@norx_aead_
$LN1@norx_aead_:
	push	esi

; 322  :     }
; 323  : 
; 324  :     memcpy(k, key, sizeof(k));

	mov	esi, DWORD PTR _key$[ebp]
	push	edi

; 325  :     norx_init(state, k, nonce);

	push	DWORD PTR _nonce$[ebp]
	lea	eax, DWORD PTR _k$[ebp]
	push	eax
	lea	eax, DWORD PTR _state$[ebp]
	lea	edi, DWORD PTR _k$[ebp]
	push	eax
	rep movsb
	call	_norx_init

; 326  :     norx_absorb_data(state, a, alen, HEADER_TAG);

	push	1
	push	DWORD PTR _alen$[ebp]
	lea	eax, DWORD PTR _state$[ebp]
	push	DWORD PTR _a$[ebp]
	push	eax
	call	_norx_absorb_data

; 327  :     norx_decrypt_data(state, m, c, clen - BYTES(NORX_T));

	mov	edi, DWORD PTR _c$[ebp]
	lea	esi, DWORD PTR [ebx-16]
	push	esi
	push	edi
	push	DWORD PTR _m$[ebp]
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_norx_decrypt_data

; 328  :     norx_absorb_data(state, z, zlen, TRAILER_TAG);

	push	4
	push	DWORD PTR _zlen$[ebp]
	lea	eax, DWORD PTR _state$[ebp]
	push	DWORD PTR _z$[ebp]
	push	eax
	call	_norx_absorb_data

; 329  :     norx_finalise(state, tag, k);

	lea	eax, DWORD PTR _k$[ebp]
	push	eax
	lea	eax, DWORD PTR _tag$[ebp]
	push	eax
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_norx_finalise

; 330  :     *mlen = clen - BYTES(NORX_T);

	mov	eax, DWORD PTR _mlen$[ebp]
	mov	DWORD PTR [eax], esi
	add	esp, 72					; 00000048H

; 331  : 
; 332  :     result = norx_verify_tag(c + clen - BYTES(NORX_T), tag);

	lea	eax, DWORD PTR _tag$[ebp]
	push	eax

; 333  :     return result;

	lea	eax, DWORD PTR [edi+ebx-16]
	push	eax
	call	_norx_verify_tag
	pop	ecx
	pop	ecx
	pop	edi
	pop	esi
$LN2@norx_aead_:
	pop	ebx

; 334  : }

	leave
	ret	0
_norx_aead_decrypt ENDP
_TEXT	ENDS
END
