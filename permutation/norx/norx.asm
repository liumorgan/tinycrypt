; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	c:\hub\tinycrypt\permutation\norx\norx.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_norx_permute
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\permutation\norx\norx.c
;	COMDAT _norx_permute
_TEXT	SEGMENT
_idx16$ = -44						; size = 32
tv90 = -12						; size = 4
_c$ = -8						; size = 4
_d$ = -4						; size = 4
_j$ = 8							; size = 4
_state$ = 8						; size = 4
_r$ = 12						; size = 4
_rnds$ = 12						; size = 4
_norx_permute PROC					; COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 54   :     int      i, j, idx;
; 55   :     uint32_t a, b, c, d, r, t;
; 56   :     norx_word_t *s=(norx_word_t*)state;
; 57   :     
; 58   :     uint16_t idx16[16]=
; 59   :     { 0xC840, 0xD951, 0xEA62, 0xFB73,    // column index

	mov	eax, 51264				; 0000c840H
	mov	WORD PTR _idx16$[ebp], ax
	mov	eax, 55633				; 0000d951H
	mov	WORD PTR _idx16$[ebp+2], ax
	mov	eax, 60002				; 0000ea62H
	mov	WORD PTR _idx16$[ebp+4], ax
	mov	eax, 64371				; 0000fb73H
	mov	WORD PTR _idx16$[ebp+6], ax

; 60   :       0xFA50, 0xCB61, 0xD872, 0xE943 };  // diagnonal index

	mov	eax, 64080				; 0000fa50H
	mov	WORD PTR _idx16$[ebp+8], ax
	mov	eax, 52065				; 0000cb61H
	mov	WORD PTR _idx16$[ebp+10], ax
	mov	eax, 55410				; 0000d872H
	mov	WORD PTR _idx16$[ebp+12], ax
	push	edi
	mov	eax, 59715				; 0000e943H
	mov	WORD PTR _idx16$[ebp+14], ax
	xor	eax, eax
	lea	edi, DWORD PTR _idx16$[ebp+16]
	stosd
	stosd
	stosd
	stosd

; 61   :     
; 62   :     for (i=0; i<rnds; i++) {

	mov	eax, DWORD PTR _rnds$[ebp]
	test	eax, eax
	jle	$LN7@norx_permu

; 54   :     int      i, j, idx;
; 55   :     uint32_t a, b, c, d, r, t;
; 56   :     norx_word_t *s=(norx_word_t*)state;
; 57   :     
; 58   :     uint16_t idx16[16]=
; 59   :     { 0xC840, 0xD951, 0xEA62, 0xFB73,    // column index

	mov	edi, DWORD PTR _state$[ebp]
	push	ebx
	mov	DWORD PTR tv90[ebp], eax
	push	esi
$LL17@norx_permu:

; 63   :       for (j=0; j<8; j++) {

	and	DWORD PTR _j$[ebp], 0
$LL18@norx_permu:

; 64   :         idx = idx16[j];

	mov	eax, DWORD PTR _j$[ebp]
	movzx	eax, WORD PTR _idx16$[ebp+eax*2]

; 65   :         
; 66   :         a = (idx         & 0xF);
; 67   :         b = ((idx >>  4) & 0xF);

	mov	edx, eax

; 68   :         c = ((idx >>  8) & 0xF);

	mov	ecx, eax
	mov	esi, eax
	push	15					; 0000000fH
	pop	ebx
	sar	edx, 4
	sar	ecx, 8
	and	ecx, ebx

; 69   :         d = ((idx >> 12) & 0xF);

	sar	eax, 12					; 0000000cH
	and	esi, ebx
	and	edx, ebx
	and	eax, ebx
	mov	DWORD PTR _c$[ebp], ecx
	mov	DWORD PTR _d$[ebp], eax

; 70   :     
; 71   :         r = 0x1F100B08;

	mov	DWORD PTR _r$[ebp], 521145096		; 1f100b08H
$LL3@norx_permu:

; 72   :         
; 73   :         /* The quarter-round */
; 74   :         do {
; 75   :           s[a] = H(s[a], s[b]); 

	mov	ebx, DWORD PTR [edi+esi*4]
	mov	ecx, DWORD PTR [edi+edx*4]
	mov	eax, ebx
	and	eax, ecx
	add	eax, eax
	xor	eax, ebx

; 76   :           s[d] = ROTR(s[d] ^ s[a], r & 0xFF);

	movzx	ebx, BYTE PTR _r$[ebp]

; 77   :           XCHG(c, a);
; 78   :           XCHG(d, b);
; 79   :           r >>= 8;

	shr	DWORD PTR _r$[ebp], 8
	xor	eax, ecx
	push	32					; 00000020H
	pop	ecx
	sub	ecx, ebx
	mov	ebx, DWORD PTR _d$[ebp]
	mov	DWORD PTR [edi+esi*4], eax
	mov	ebx, DWORD PTR [edi+ebx*4]
	xor	ebx, eax
	mov	eax, DWORD PTR _d$[ebp]
	rol	ebx, cl

; 80   :         } while (r != 0);

	cmp	DWORD PTR _r$[ebp], 0
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], esi
	mov	DWORD PTR _d$[ebp], edx
	mov	DWORD PTR [edi+eax*4], ebx
	mov	esi, ecx
	mov	edx, eax
	jne	SHORT $LL3@norx_permu

; 63   :       for (j=0; j<8; j++) {

	inc	DWORD PTR _j$[ebp]
	cmp	DWORD PTR _j$[ebp], 8
	jl	SHORT $LL18@norx_permu

; 61   :     
; 62   :     for (i=0; i<rnds; i++) {

	dec	DWORD PTR tv90[ebp]
	jne	$LL17@norx_permu
	pop	esi
	pop	ebx
$LN7@norx_permu:
	pop	edi

; 81   :       }
; 82   :     }
; 83   : }

	leave
	ret	0
_norx_permute ENDP
_TEXT	ENDS
END
