; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	c:\hub\tinycrypt\permutation\norx\norx.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_norx_permute
; Function compile flags: /Ogspy
; File c:\hub\tinycrypt\permutation\norx\norx.c
;	COMDAT _norx_permute
_TEXT	SEGMENT
tv575 = -20						; size = 4
_idx16$ = -16						; size = 16
_j$1$ = 8						; size = 4
_state$ = 8						; size = 4
_norx_permute PROC					; COMDAT

; 42   : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 43   :     int      i, j, idx;
; 44   :     uint32_t a, b, c, d;
; 45   :     norx_word_t *s=(norx_word_t*)state;
; 46   :     
; 47   :     uint16_t idx16[8]=

	mov	ebp, DWORD PTR _state$[esp+24]
	push	esi
	push	edi
	mov	DWORD PTR _idx16$[esp+36], -648951744	; d951c840H
	mov	DWORD PTR _idx16$[esp+40], -76289438	; fb73ea62H
	mov	DWORD PTR _idx16$[esp+44], -882771376	; cb61fa50H
	mov	DWORD PTR _idx16$[esp+48], -381429646	; e943d872H
	mov	DWORD PTR tv575[esp+36], 4
$LL4@norx_permu:

; 52   :       for (j=0; j<8; j++) {

	xor	eax, eax
	mov	DWORD PTR _j$1$[esp+32], eax
$LL7@norx_permu:

; 53   :         idx = idx16[j];

	movzx	edi, WORD PTR _idx16$[esp+eax*2+36]

; 54   :         
; 55   :         a = (idx         & 0xF);

	mov	edx, edi

; 56   :         b = ((idx >>  4) & 0xF);

	mov	ebx, edi
	and	edx, 15					; 0000000fH
	shr	ebx, 4
	and	ebx, 15					; 0000000fH

; 57   :         c = ((idx >>  8) & 0xF);

	mov	esi, edi

; 58   :         d = ((idx >> 12) & 0xF);

	shr	edi, 12					; 0000000cH
	shr	esi, 8

; 59   :     
; 60   :          /* The quarter-round */
; 61   :         s[a] = H(s[a], s[b]); 

	mov	al, BYTE PTR [edx+ebp]
	and	esi, 15					; 0000000fH
	and	al, BYTE PTR [ebx+ebp]
	add	al, al
	xor	al, BYTE PTR [edx+ebp]
	xor	al, BYTE PTR [ebx+ebp]
	mov	BYTE PTR [edx+ebp], al

; 62   :         s[d] = ROTR(s[d] ^ s[a], R0);

	mov	cl, BYTE PTR [edi+ebp]
	xor	cl, al
	shr	cl, 1
	mov	BYTE PTR [edi+ebp], cl

; 63   :         
; 64   :         s[c] = H(s[c], s[d]); 

	mov	al, cl
	and	al, BYTE PTR [esi+ebp]
	add	al, al
	xor	al, cl
	xor	BYTE PTR [esi+ebp], al

; 65   :         s[b] = ROTR(s[b] ^ s[c], R1); 

	mov	cl, BYTE PTR [ebx+ebp]
	xor	cl, BYTE PTR [esi+ebp]
	shr	cl, 3
	mov	BYTE PTR [ebx+ebp], cl

; 66   :         
; 67   :         s[a] = H(s[a], s[b]); 

	mov	al, cl
	and	al, BYTE PTR [edx+ebp]
	add	al, al
	xor	al, cl
	xor	BYTE PTR [edx+ebp], al

; 68   :         s[d] = ROTR(s[d] ^ s[a], R2); 

	mov	cl, BYTE PTR [edi+ebp]
	xor	cl, BYTE PTR [edx+ebp]
	shr	cl, 5
	mov	BYTE PTR [edi+ebp], cl

; 69   :         
; 70   :         s[c] = H(s[c], s[d]); 

	mov	al, cl
	and	al, BYTE PTR [esi+ebp]
	add	al, al
	xor	al, cl
	xor	BYTE PTR [esi+ebp], al

; 71   :         s[b] = ROTR(s[b] ^ s[c], R3); 

	mov	cl, BYTE PTR [ebx+ebp]
	xor	cl, BYTE PTR [esi+ebp]
	mov	eax, DWORD PTR _j$1$[esp+32]
	shr	cl, 7
	inc	eax
	mov	BYTE PTR [ebx+ebp], cl
	mov	DWORD PTR _j$1$[esp+32], eax
	cmp	eax, 8
	jl	$LL7@norx_permu

; 48   :     { 0xC840, 0xD951, 0xEA62, 0xFB73,    // column index
; 49   :       0xFA50, 0xCB61, 0xD872, 0xE943 };  // diagnonal index
; 50   :     
; 51   :     for (i=0; i<NORX_L; i++) {

	sub	DWORD PTR tv575[esp+36], 1
	jne	$LL4@norx_permu
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 72   :       }
; 73   :     }
; 74   : }

	add	esp, 20					; 00000014H
	ret	0
_norx_permute ENDP
_TEXT	ENDS
END
