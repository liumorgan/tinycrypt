; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	c:\hub\sha3\keccak\k400.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_rc
; Function compile flags: /Ogspy
; File c:\hub\sha3\keccak\k400.c
;	COMDAT _rc
_TEXT	SEGMENT
_c$ = -4						; size = 2
_LFSR$ = 8						; size = 4
_rc	PROC						; COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 36   :   uint16_t c; 
; 37   :   int8_t   t;
; 38   :   uint8_t  i;
; 39   : 
; 40   :   c = 0;

	and	DWORD PTR _c$[ebp], 0
	push	ebx
	push	esi

; 41   :   t = *LFSR;

	mov	esi, DWORD PTR _LFSR$[ebp]
	mov	dl, BYTE PTR [esi]

; 42   :   
; 43   :   for (i=1; i<128; i += i) 

	mov	bl, 1
$LL5@rc:

; 44   :   {
; 45   :     if (t & 1) {

	test	dl, 1
	je	SHORT $LN12@rc

; 46   :       // if shift value is < 16
; 47   :       if ((i-1) < 16) {

	movzx	eax, bl
	lea	ecx, DWORD PTR [eax-1]
	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN12@rc

; 48   :         c ^= 1UL << (i - 1);

	lea	ecx, DWORD PTR [eax-1]
	xor	eax, eax
	inc	eax
	shl	ax, cl
	xor	WORD PTR _c$[ebp], ax
$LN12@rc:

; 49   :       }
; 50   :     }
; 51   :     t = (t & 0x80) ? (t << 1) ^ 0x71 : t << 1;

	test	dl, dl
	jns	SHORT $LN8@rc
	add	dl, dl
	xor	dl, 113					; 00000071H
	jmp	SHORT $LN9@rc
$LN8@rc:
	add	dl, dl
$LN9@rc:

; 42   :   
; 43   :   for (i=1; i<128; i += i) 

	add	bl, bl
	cmp	bl, 128					; 00000080H
	jb	SHORT $LL5@rc

; 52   :   }
; 53   :   *LFSR = (uint8_t)t;
; 54   :   return c;

	mov	ax, WORD PTR _c$[ebp]
	mov	BYTE PTR [esi], dl
	pop	esi
	pop	ebx

; 55   : }

	leave
	ret	0
_rc	ENDP
_TEXT	ENDS
PUBLIC	_k400_permute
; Function compile flags: /Ogspy
;	COMDAT _k400_permute
_TEXT	SEGMENT
_keccakf_piln$ = -52					; size = 24
_bc$ = -28						; size = 10
_keccakf_mod5$ = -16					; size = 10
_lfsr$ = -1						; size = 1
tv1262 = 8						; size = 4
_state$ = 8						; size = 4
_k400_permute PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	ebx

; 59   :   int     i, j, rnd, r;
; 60   :   uint16_t t, bc[5];
; 61   :   uint8_t  lfsr=1;
; 62   :   uint16_t *st=(uint16_t*)state;
; 63   :   
; 64   : const uint8_t keccakf_piln[24] = 
; 65   : { 10, 7,  11, 17, 18, 3, 5,  16, 8,  21, 24, 4, 
; 66   :   15, 23, 19, 13, 12, 2, 20, 14, 22, 9,  6,  1  };
; 67   : 
; 68   : const uint8_t keccakf_mod5[10] = 
; 69   : { 0, 1, 2, 3, 4, 0, 1, 2, 3, 4 };

	mov	ebx, DWORD PTR _state$[ebp]
	push	esi
	push	edi
	mov	BYTE PTR _lfsr$[ebp], 1
	mov	DWORD PTR _keccakf_piln$[ebp], 285935370 ; 110b070aH
	mov	DWORD PTR _keccakf_piln$[ebp+4], 268763922 ; 10050312H
	mov	DWORD PTR _keccakf_piln$[ebp+8], 68687112 ; 04181508H
	mov	DWORD PTR _keccakf_piln$[ebp+12], 219354895 ; 0d13170fH
	mov	DWORD PTR _keccakf_piln$[ebp+16], 236192268 ; 0e14020cH
	mov	DWORD PTR _keccakf_piln$[ebp+20], 17172758 ; 01060916H
	mov	DWORD PTR _keccakf_mod5$[ebp], 50462976	; 03020100H
	mov	DWORD PTR _keccakf_mod5$[ebp+4], 33619972 ; 02010004H
	mov	WORD PTR _keccakf_mod5$[ebp+8], 1027	; 00000403H
	mov	DWORD PTR tv1262[ebp], 20		; 00000014H
$LL24@k400_permu:

; 70   :   
; 71   :   for (rnd=0; rnd<20; rnd++) 
; 72   :   {
; 73   :     // Theta
; 74   :     for (i=0; i<5; i++) {     

	xor	ecx, ecx
	lea	eax, DWORD PTR [ebx+30]
$LL21@k400_permu:

; 75   :       bc[i] = st[i] 
; 76   :             ^ st[i +  5] 
; 77   :             ^ st[i + 10] 
; 78   :             ^ st[i + 15] 
; 79   :             ^ st[i + 20];

	mov	dx, WORD PTR [eax-30]
	xor	dx, WORD PTR [eax-20]
	xor	dx, WORD PTR [eax-10]
	xor	dx, WORD PTR [eax+10]
	xor	dx, WORD PTR [eax]
	inc	ecx
	mov	WORD PTR _bc$[ebp+ecx*2-2], dx
	add	eax, 2
	cmp	ecx, 5
	jl	SHORT $LL21@k400_permu

; 80   :     }
; 81   :     for (i=0; i<5; i++) {

	xor	edx, edx
	mov	esi, ebx
$LL18@k400_permu:

; 82   :       t = bc[keccakf_mod5[(i + 4)]] ^ ROTL16(bc[keccakf_mod5[(i + 1)]], 1);

	movzx	eax, BYTE PTR _keccakf_mod5$[ebp+edx+1]
	mov	ax, WORD PTR _bc$[ebp+eax*2]
	movzx	ecx, BYTE PTR _keccakf_mod5$[ebp+edx+4]
	rol	ax, 1
	xor	ax, WORD PTR _bc$[ebp+ecx*2]
	push	5
	movzx	ecx, ax
	mov	eax, esi
	pop	edi
$LL15@k400_permu:

; 83   :       for (j=0; j<25; j+=5) {
; 84   :         st[j + i] ^= t;

	xor	WORD PTR [eax], cx
	add	eax, 10					; 0000000aH
	dec	edi
	jne	SHORT $LL15@k400_permu

; 80   :     }
; 81   :     for (i=0; i<5; i++) {

	inc	edx
	add	esi, 2
	cmp	edx, 5
	jl	SHORT $LL18@k400_permu

; 85   :       }
; 86   :     }
; 87   :     // Rho Pi
; 88   :     t = st[1];

	movzx	edi, WORD PTR [ebx+2]

; 89   :     for (i=0, r=0; i<24; i++) {

	xor	edx, edx
	xor	esi, esi
$LL12@k400_permu:

; 90   :       r += i + 1;
; 91   :       j = keccakf_piln[i];

	movzx	eax, BYTE PTR _keccakf_piln$[ebp+edx]

; 92   :       bc[0] = st[j];

	lea	eax, DWORD PTR [ebx+eax*2]
	mov	cx, WORD PTR [eax]
	lea	esi, DWORD PTR [esi+edx+1]
	mov	WORD PTR _bc$[ebp], cx

; 93   :       st[j] = ROTL16(t, r & 15);

	mov	ecx, esi
	and	ecx, 15					; 0000000fH
	rol	di, cl
	inc	edx
	mov	WORD PTR [eax], di

; 94   :       t = bc[0];

	movzx	edi, WORD PTR _bc$[ebp]
	cmp	edx, 24					; 00000018H
	jl	SHORT $LL12@k400_permu

; 95   :     }
; 96   :     // Chi
; 97   :     for (j=0; j<25; j+=5) {

	push	5
	mov	eax, ebx
	pop	edx
$LL9@k400_permu:

; 98   :       for (i=0; i<5; i++) {
; 99   :         bc[i] = st[j + i];

	mov	esi, eax
	lea	edi, DWORD PTR _bc$[ebp]
	movsd
	movsd
	movsw

; 100  :       }
; 101  :       for (i=0; i<5; i++) {

	xor	ecx, ecx
$LL3@k400_permu:

; 102  :         st[j + i] ^= (~bc[keccakf_mod5[(i + 1)]]) & bc[keccakf_mod5[(i + 2)]];

	movzx	esi, BYTE PTR _keccakf_mod5$[ebp+ecx+1]
	mov	si, WORD PTR _bc$[ebp+esi*2]
	movzx	edi, BYTE PTR _keccakf_mod5$[ebp+ecx+2]
	not	si
	and	si, WORD PTR _bc$[ebp+edi*2]
	xor	WORD PTR [eax], si
	inc	ecx
	add	eax, 2
	cmp	ecx, 5
	jl	SHORT $LL3@k400_permu

; 95   :     }
; 96   :     // Chi
; 97   :     for (j=0; j<25; j+=5) {

	dec	edx
	jne	SHORT $LL9@k400_permu

; 103  :       }
; 104  :     }
; 105  :     // Iota
; 106  :     st[0] ^= rc(&lfsr);

	lea	eax, DWORD PTR _lfsr$[ebp]
	push	eax
	call	_rc
	xor	WORD PTR [ebx], ax
	dec	DWORD PTR tv1262[ebp]
	pop	ecx
	jne	$LL24@k400_permu
	pop	edi
	pop	esi
	pop	ebx

; 107  :   }
; 108  : }

	leave
	ret	0
_k400_permute ENDP
_TEXT	ENDS
END
