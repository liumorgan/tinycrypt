; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	c:\hub\sha3\keccak\k200.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_k200_permute
; Function compile flags: /Ogspy
; File c:\hub\sha3\keccak\k200.c
;	COMDAT _k200_permute
_TEXT	SEGMENT
tv1202 = -68						; size = 4
_bc$ = -64						; size = 5
_m$ = -56						; size = 9
_rc$ = -44						; size = 18
_p$ = -24						; size = 24
_r$1$ = 8						; size = 1
_state$ = 8						; size = 4
_k200_permute PROC					; COMDAT

; 33   : {

	sub	esp, 68					; 00000044H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _state$[esp+76]

; 34   :     uint32_t i, j, rnd;
; 35   :     uint8_t  t, r, u, bc[5];
; 36   :     uint8_t  *st = (uint8_t*)state;
; 37   :   
; 38   :     uint8_t rc[18]=

	xor	eax, eax
	push	edi
	push	-19					; ffffffedH
	pop	ebx
	sub	ebx, esi
	mov	DWORD PTR _rc$[esp+84], 9077249		; 008a8201H

; 39   :     { 0x01, 0x82, 0x8a, 0x00, 0x8b, 0x01, 0x81, 0x09, 0x8a,
; 40   :       0x88, 0x09, 0x0a, 0x8b, 0x8b, 0x89, 0x03, 0x02, 0x80 };
; 41   :       
; 42   :     uint8_t p[24] = 
; 43   :     { 10, 7,  11, 17, 18, 3, 5,  16, 8,  21, 24, 4, 
; 44   :       15, 23, 19, 13, 12, 2, 20, 14, 22, 9,  6,  1  };
; 45   :       
; 46   :     uint8_t m[9] = 
; 47   :     { 0, 1, 2, 3, 4, 0, 1, 2, 3};
; 48   :   
; 49   :     for (rnd=0; rnd<18; rnd++) {

	mov	ebp, eax
	mov	DWORD PTR _rc$[esp+88], 159449483	; 0981018bH
	mov	DWORD PTR _rc$[esp+92], 168396938	; 0a09888aH
	lea	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _rc$[esp+96], 59345803	; 03898b8bH
	mov	WORD PTR _rc$[esp+100], 32770		; 00008002H
	mov	DWORD PTR _p$[esp+84], 285935370	; 110b070aH
	mov	DWORD PTR _p$[esp+88], 268763922	; 10050312H
	mov	DWORD PTR _p$[esp+92], 68687112		; 04181508H
	mov	DWORD PTR _p$[esp+96], 219354895	; 0d13170fH
	mov	DWORD PTR _p$[esp+100], 236192268	; 0e14020cH
	mov	DWORD PTR _p$[esp+104], 17172758	; 01060916H
	mov	DWORD PTR _m$[esp+84], 50462976		; 03020100H
	mov	DWORD PTR _m$[esp+88], 33619972		; 02010004H
	mov	BYTE PTR _m$[esp+92], 3
	mov	DWORD PTR tv1202[esp+84], ebx
$LL4@k200_permu:

; 50   :       // Theta
; 51   :       for (i=5; (int)i>=0; i--) {

	lea	edx, DWORD PTR _bc$[esp+88]
	mov	ecx, eax
$LL7@k200_permu:

; 52   :         t  = st[i-1   ];
; 53   :         t ^= st[i+ 5-1];      
; 54   :         t ^= st[i+10-1];      
; 55   :         t ^= st[i+15-1];      
; 56   :         t ^= st[i+20-1];

	mov	al, BYTE PTR [ecx-20]
	xor	al, BYTE PTR [ecx-15]
	xor	al, BYTE PTR [ecx-10]
	xor	al, BYTE PTR [ecx-5]
	xor	al, BYTE PTR [ecx]
	dec	ecx

; 57   :         bc[i-1] = t;

	mov	BYTE PTR [edx], al
	dec	edx
	lea	eax, DWORD PTR [ebx+ecx]
	test	eax, eax
	jns	SHORT $LL7@k200_permu

; 58   :       }
; 59   :       for (i=0; i<5; i++) {

	xor	ecx, ecx
$LL10@k200_permu:

; 60   :         t  = bc[m[(i + 4)]]; 
; 61   :         t ^= ROTL8(bc[m[(i + 1)]], 1);

	movzx	eax, BYTE PTR _m$[esp+ecx+85]
	mov	dl, BYTE PTR _bc$[esp+eax+84]
	movzx	eax, BYTE PTR _m$[esp+ecx+88]
	rol	dl, 1
	xor	dl, BYTE PTR _bc$[esp+eax+84]

; 62   :         for (j=i; j<25; j+=5) {

	mov	eax, ecx
	cmp	ecx, 25					; 00000019H
	jae	SHORT $LN8@k200_permu
$LL13@k200_permu:

; 63   :           st[j] ^= t;

	xor	BYTE PTR [eax+esi], dl
	add	eax, 5
	cmp	eax, 25					; 00000019H
	jb	SHORT $LL13@k200_permu
$LN8@k200_permu:

; 58   :       }
; 59   :       for (i=0; i<5; i++) {

	inc	ecx
	cmp	ecx, 5
	jb	SHORT $LL10@k200_permu

; 64   :         }
; 65   :       }
; 66   :       // Rho + Pi
; 67   :       u = st[1];

	mov	ah, BYTE PTR [esi+1]

; 68   :       for (i=0, r=0; i<24; i++) {

	xor	ebx, ebx
	xor	cl, cl
$LL16@k200_permu:

; 69   :         r += i + 1;
; 70   :         u  = ROTL8(u, r & 7);
; 71   :         XCHG(st[p[i]], u);

	movzx	edx, BYTE PTR _p$[esp+ebx+84]
	mov	al, bl
	inc	al
	add	cl, al
	mov	BYTE PTR _r$1$[esp+80], cl
	mov	al, BYTE PTR [edx+esi]
	movzx	ecx, cl
	and	ecx, 7
	rol	ah, cl
	inc	ebx
	mov	cl, BYTE PTR _r$1$[esp+80]
	mov	BYTE PTR [edx+esi], ah
	mov	ah, al
	cmp	ebx, 24					; 00000018H
	jb	SHORT $LL16@k200_permu

; 72   :         bc[0] = u;
; 73   :       }
; 74   :       // Chi
; 75   :       for (i=0; i<25; i+=5) {

	push	5
	mov	edx, esi
	pop	ebx
$LL19@k200_permu:

; 76   :         memcpy(&bc, &st[i], 5);

	mov	eax, DWORD PTR [edx]

; 77   :         for (j=0; j<5; j++) {

	xor	edi, edi
	mov	DWORD PTR _bc$[esp+84], eax
	mov	al, BYTE PTR [edx+4]
	mov	BYTE PTR _bc$[esp+88], al
$LL22@k200_permu:

; 78   :           t  = ~bc[m[(j + 1)]];

	movzx	eax, BYTE PTR _m$[esp+edi+85]
	mov	cl, BYTE PTR _bc$[esp+eax+84]

; 79   :           t &=  bc[m[(j + 2)]];

	movzx	eax, BYTE PTR _m$[esp+edi+86]
	not	cl
	and	cl, BYTE PTR _bc$[esp+eax+84]

; 80   :           st[j + i] ^= t;

	xor	BYTE PTR [edx], cl
	inc	edi
	inc	edx
	cmp	edi, 5
	jb	SHORT $LL22@k200_permu

; 72   :         bc[0] = u;
; 73   :       }
; 74   :       // Chi
; 75   :       for (i=0; i<25; i+=5) {

	sub	ebx, 1
	jne	SHORT $LL19@k200_permu

; 81   :         }
; 82   :       }
; 83   :       // Iota
; 84   :       st[0] ^= rc[rnd];

	mov	al, BYTE PTR _rc$[esp+ebp+84]
	xor	BYTE PTR [esi], al
	inc	ebp
	mov	ebx, DWORD PTR tv1202[esp+84]
	lea	eax, DWORD PTR [esi+24]
	cmp	ebp, 18					; 00000012H
	jb	$LL4@k200_permu
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 85   :     }
; 86   : }

	add	esp, 68					; 00000044H
	ret	0
_k200_permute ENDP
_TEXT	ENDS
END
